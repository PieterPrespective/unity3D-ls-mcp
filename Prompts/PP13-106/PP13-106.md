# PP13-106: Phase 4 - Testing Infrastructure

## Assignment Overview

| Field | Value |
|-------|-------|
| **Issue ID** | PP13-106 |
| **Parent Issue** | PP13-102 |
| **Depends On** | PP13-104 (Phase 2), PP13-105 (Phase 3) |
| **Phase** | 4 of 5 |
| **Title** | Testing Infrastructure |
| **Reference** | [DevRoadmap.md](../../Documentation/tdd/DevRoadmap.md) - Phase 4 |
| **Technical Analysis** | [Unity-CSharp-LSP-MCP-Honest-Report.md](../../Documentation/tdd/Unity-CSharp-LSP-MCP-Honest-Report.md) |

---

## Objective

Create a comprehensive testing infrastructure for ULSM that validates Unity workspace loading, Unity-specific analysis tools, and integration with actual Unity project structures. This includes:

1. A NUnit test project (`ULSM.Tests`) with unit and integration tests
2. A minimal Unity test project (`UnityTestProject`) for integration testing
3. Tests covering all Unity-specific components from Phase 2 and Phase 3
4. CI/CD-ready test organization with appropriate categorization

---

## Background: Why Testing Is Critical

ULSM's Unity-specific functionality has several failure modes that require comprehensive testing:

1. **Workspace Loading**: MSBuildWorkspace may fail with Unity's legacy csproj format
2. **Fallback Behavior**: AdhocWorkspace fallback must work when MSBuild fails
3. **Platform Differences**: Framework path resolution differs between Windows/macOS/Linux
4. **Analyzer Loading**: Microsoft.Unity.Analyzers may not load correctly at runtime
5. **Pattern Detection**: Custom pattern analyzers must correctly identify MonoBehaviour classes
6. **API Migration**: Text-based search must find deprecation patterns accurately

Without tests, regressions in any of these areas would go undetected until production use.

---

## Pre-Implementation Checklist

Before starting implementation, verify:

- [ ] Read and understand `Prompts/BasePrompt.md` for project conventions
- [ ] Read `Documentation/tdd/DevRoadmap.md` Phase 4 section completely
- [ ] Verify dev-diary branch is `ULSM-PWS` (not `main`)
- [ ] Verify knowledge-agent branch is `ULSM-PWS` (not `main`)
- [ ] Verify PP13-105 commits are present (`git log --oneline -5`)
- [ ] `dotnet build ULSM.sln` succeeds on current codebase
- [ ] Create registry entry for PP13-106 in dev diary
- [ ] Log implementation plan in dev diary

---

## Architecture Overview

### Phase 4 Project Structure

```
ULSM/
├── src/
│   ├── ULSM.csproj                          (existing)
│   ├── Program.cs                           (existing)
│   ├── McpServer.cs                         (existing)
│   ├── RoslynService.cs                     (existing)
│   └── Unity/
│       ├── UnityProjectDetector.cs          (existing - PP13-104)
│       ├── UnityWorkspaceLoader.cs          (existing - PP13-104)
│       ├── UnityAdhocWorkspaceBuilder.cs    (existing - PP13-104)
│       ├── UnityAnalysisService.cs          (existing - PP13-105)
│       └── Analyzers/
│           ├── UnityAnalyzerLoader.cs       (existing - PP13-105)
│           ├── UnityPatternAnalyzer.cs      (existing - PP13-105)
│           └── UnityApiMigrationData.cs     (existing - PP13-105)
│
├── tests/
│   ├── ULSM.Tests/                          ◄── NEW
│   │   ├── ULSM.Tests.csproj
│   │   ├── GlobalUsings.cs
│   │   ├── TestHelpers/
│   │   │   └── TestPaths.cs
│   │   ├── Unit/
│   │   │   ├── UnityProjectDetectorTests.cs
│   │   │   ├── UnityWorkspaceLoaderTests.cs
│   │   │   ├── UnityAnalyzerLoaderTests.cs
│   │   │   ├── UnityPatternAnalyzerTests.cs
│   │   │   └── UnityApiMigrationDataTests.cs
│   │   └── Integration/
│   │       ├── UnityProjectIntegrationTests.cs
│   │       └── UnityAnalysisIntegrationTests.cs
│   │
│   └── UnityTestProject/                    ◄── NEW (Minimal Unity-like structure)
│       ├── Assets/
│       │   └── Scripts/
│       │       ├── TestMonoBehaviour.cs
│       │       ├── TestScriptableObject.cs
│       │       └── TestPatterns.cs          (intentional anti-patterns)
│       ├── ProjectSettings/
│       │   └── ProjectVersion.txt
│       ├── Assembly-CSharp.csproj
│       └── UnityTestProject.sln
│
├── ULSM.sln                                 (modify - add test project)
└── Documentation/
```

### Test Categories

| Category | Purpose | Execution |
|----------|---------|-----------|
| `Unit` | Fast, isolated component tests | Every build |
| `Integration` | Full project loading tests | CI/CD, manual |
| `Platform` | Platform-specific tests (framework paths) | Tagged by OS |

---

## Implementation Tasks

### Task 1: Create Test Project Structure

Create the folder structure for tests.

```bash
# Create test project folders
mkdir -p tests/ULSM.Tests/TestHelpers
mkdir -p tests/ULSM.Tests/Unit
mkdir -p tests/ULSM.Tests/Integration

# Create Unity test project structure
mkdir -p tests/UnityTestProject/Assets/Scripts
mkdir -p tests/UnityTestProject/ProjectSettings
```

---

### Task 2: Create ULSM.Tests Project

**File:** `tests/ULSM.Tests/ULSM.Tests.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
    <RootNamespace>ULSM.Tests</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <!-- NUnit Testing Framework -->
    <PackageReference Include="NUnit" Version="4.2.2" />
    <PackageReference Include="NUnit3TestAdapter" Version="4.6.0" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.1" />
    <PackageReference Include="NUnit.Analyzers" Version="4.3.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>

    <!-- Code Coverage -->
    <PackageReference Include="coverlet.collector" Version="6.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <!-- Reference to main project -->
    <ProjectReference Include="..\..\src\ULSM.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- Include Unity test project files as content -->
    <None Include="..\UnityTestProject\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="UnityTestProject" />
  </ItemGroup>
</Project>
```

---

### Task 3: Create Global Usings

**File:** `tests/ULSM.Tests/GlobalUsings.cs`

```csharp
global using NUnit.Framework;
global using ULSM;
global using ULSM.Unity;
global using ULSM.Unity.Analyzers;
```

---

### Task 4: Create Test Helpers

**File:** `tests/ULSM.Tests/TestHelpers/TestPaths.cs`

```csharp
namespace ULSM.Tests.TestHelpers;

/// <summary>
/// Provides consistent paths to test resources across all test classes.
/// Handles the complexity of finding test files relative to the test execution directory.
/// </summary>
public static class TestPaths
{
    private static string? _testProjectRoot;

    /// <summary>
    /// Gets the root directory of the test project.
    /// </summary>
    public static string TestProjectRoot
    {
        get
        {
            if (_testProjectRoot != null)
                return _testProjectRoot;

            // Start from test execution directory and navigate up to find tests folder
            var currentDir = TestContext.CurrentContext.TestDirectory;

            // Navigate up until we find the tests folder or ULSM.sln
            while (currentDir != null)
            {
                var testsDir = Path.Combine(currentDir, "tests");
                var slnFile = Path.Combine(currentDir, "ULSM.sln");

                if (Directory.Exists(testsDir) || File.Exists(slnFile))
                {
                    _testProjectRoot = currentDir;
                    return _testProjectRoot;
                }

                currentDir = Directory.GetParent(currentDir)?.FullName;
            }

            // Fallback: use test directory
            _testProjectRoot = TestContext.CurrentContext.TestDirectory;
            return _testProjectRoot;
        }
    }

    /// <summary>
    /// Gets the path to the Unity test project solution file.
    /// </summary>
    public static string UnityTestSolutionPath =>
        Path.Combine(TestProjectRoot, "tests", "UnityTestProject", "UnityTestProject.sln");

    /// <summary>
    /// Gets the path to the Unity test project folder.
    /// </summary>
    public static string UnityTestProjectPath =>
        Path.Combine(TestProjectRoot, "tests", "UnityTestProject");

    /// <summary>
    /// Gets the path to the main ULSM solution file.
    /// </summary>
    public static string MainSolutionPath =>
        Path.Combine(TestProjectRoot, "ULSM.sln");

    /// <summary>
    /// Gets the path to a specific test script in the Unity test project.
    /// </summary>
    /// <param name="scriptName">Name of the script file (e.g., "TestPatterns.cs")</param>
    /// <returns>Full path to the script file.</returns>
    public static string GetUnityScriptPath(string scriptName) =>
        Path.Combine(UnityTestProjectPath, "Assets", "Scripts", scriptName);

    /// <summary>
    /// Gets the path to the Assembly-CSharp.csproj in the Unity test project.
    /// </summary>
    public static string UnityAssemblyCSharpPath =>
        Path.Combine(UnityTestProjectPath, "Assembly-CSharp.csproj");

    /// <summary>
    /// Checks if the Unity test project exists and is properly set up.
    /// </summary>
    public static bool UnityTestProjectExists =>
        File.Exists(UnityTestSolutionPath) &&
        File.Exists(UnityAssemblyCSharpPath) &&
        Directory.Exists(Path.Combine(UnityTestProjectPath, "Assets"));

    /// <summary>
    /// Skips the current test if the Unity test project is not available.
    /// </summary>
    public static void SkipIfUnityTestProjectMissing()
    {
        if (!UnityTestProjectExists)
        {
            Assert.Ignore("Unity test project not found. Skipping integration test.");
        }
    }
}
```

---

### Task 5: Create Minimal Unity Test Project

#### 5.1 Solution File

**File:** `tests/UnityTestProject/UnityTestProject.sln`

```
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Assembly-CSharp", "Assembly-CSharp.csproj", "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal
```

#### 5.2 Unity-Style Project File

**File:** `tests/UnityTestProject/Assembly-CSharp.csproj`

This mimics Unity's legacy csproj format for testing purposes. Note: This is a simplified version that doesn't require actual Unity DLLs for basic detection tests.

```xml
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>10.0.20506</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <RootNamespace></RootNamespace>
    <ProjectGuid>{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AssemblyName>Assembly-CSharp</AssemblyName>
    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <BaseDirectory>.</BaseDirectory>
    <LangVersion>9.0</LangVersion>
    <DefineConstants>UNITY_6000_0_OR_NEWER;UNITY_6000;UNITY_EDITOR;UNITY_EDITOR_WIN;PLATFORM_ARCH_64</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>Temp\bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE;UNITY_6000_0_OR_NEWER;UNITY_6000;UNITY_EDITOR</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>Temp\bin\Release\</OutputPath>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <!-- Simulated Unity references - these paths would be absolute in real Unity projects -->
    <!-- For testing, we reference the paths even if they don't exist -->
    <Reference Include="UnityEngine">
      <HintPath>C:\Program Files\Unity\Hub\Editor\6000.0.0f1\Editor\Data\Managed\UnityEngine\UnityEngine.dll</HintPath>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>C:\Program Files\Unity\Hub\Editor\6000.0.0f1\Editor\Data\Managed\UnityEngine\UnityEngine.CoreModule.dll</HintPath>
    </Reference>
    <Reference Include="UnityEditor">
      <HintPath>C:\Program Files\Unity\Hub\Editor\6000.0.0f1\Editor\Data\Managed\UnityEngine\UnityEditor.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Assets\Scripts\TestMonoBehaviour.cs" />
    <Compile Include="Assets\Scripts\TestScriptableObject.cs" />
    <Compile Include="Assets\Scripts\TestPatterns.cs" />
  </ItemGroup>
</Project>
```

#### 5.3 Project Version File

**File:** `tests/UnityTestProject/ProjectSettings/ProjectVersion.txt`

```
m_EditorVersion: 6000.0.0f1
m_EditorVersionWithRevision: 6000.0.0f1 (abcdef123456)
```

#### 5.4 Test Scripts

**File:** `tests/UnityTestProject/Assets/Scripts/TestMonoBehaviour.cs`

```csharp
// Simulated Unity types for testing (when real Unity DLLs are not available)
#if !UNITY_EDITOR
namespace UnityEngine
{
    public class Object { }
    public class Component : Object { }
    public class Behaviour : Component { }
    public class MonoBehaviour : Behaviour
    {
        public GameObject gameObject { get; set; }
        public Transform transform { get; set; }
        public T GetComponent<T>() where T : Component => default;
    }
    public class ScriptableObject : Object { }
    public class GameObject : Object
    {
        public string tag { get; set; }
        public bool CompareTag(string tag) => false;
    }
    public class Transform : Component { }
    public class Camera : Behaviour
    {
        public static Camera main { get; }
    }
    public class Debug
    {
        public static void Log(object message) { }
        public static void LogWarning(object message) { }
        public static void LogError(object message) { }
    }
    public class SerializeFieldAttribute : System.Attribute { }
}
#endif

using UnityEngine;

/// <summary>
/// Valid MonoBehaviour for testing symbol resolution and references.
/// This class demonstrates proper Unity patterns.
/// </summary>
public class TestMonoBehaviour : MonoBehaviour
{
    [SerializeField]
    private float speed = 5f;

    [SerializeField]
    private string playerName = "Player";

    private Transform cachedTransform;
    private Camera mainCamera;

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => playerName;
        set => playerName = value;
    }

    /// <summary>
    /// Called when the script instance is being loaded.
    /// Demonstrates proper caching pattern.
    /// </summary>
    private void Awake()
    {
        // Good pattern: cache references in Awake
        cachedTransform = transform;
        mainCamera = Camera.main;
    }

    /// <summary>
    /// Called on the frame when a script is enabled.
    /// </summary>
    private void Start()
    {
        Debug.Log($"TestMonoBehaviour started with speed {speed}");
    }

    /// <summary>
    /// Called every frame.
    /// </summary>
    private void Update()
    {
        // Uses cached reference - good pattern
        if (cachedTransform != null)
        {
            // Movement logic would go here
        }
    }

    /// <summary>
    /// Example public method for testing find references.
    /// </summary>
    /// <param name="value">A test value.</param>
    public void DoSomething(int value)
    {
        Debug.Log($"DoSomething called with {value}");
    }

    /// <summary>
    /// Example method with multiple parameters.
    /// </summary>
    /// <param name="name">The name parameter.</param>
    /// <param name="count">The count parameter.</param>
    /// <returns>A formatted string.</returns>
    public string FormatMessage(string name, int count)
    {
        return $"{name}: {count}";
    }
}
```

**File:** `tests/UnityTestProject/Assets/Scripts/TestScriptableObject.cs`

```csharp
#if !UNITY_EDITOR
// Using simulated types from TestMonoBehaviour.cs
#endif

using UnityEngine;

/// <summary>
/// Test ScriptableObject for testing Unity-specific patterns.
/// </summary>
public class TestScriptableObject : ScriptableObject
{
    [SerializeField]
    private string itemName = "Default";

    [SerializeField]
    private int itemValue = 100;

    /// <summary>
    /// Gets the item name.
    /// </summary>
    public string ItemName => itemName;

    /// <summary>
    /// Gets the item value.
    /// </summary>
    public int ItemValue => itemValue;
}
```

**File:** `tests/UnityTestProject/Assets/Scripts/TestPatterns.cs`

```csharp
#if !UNITY_EDITOR
// Using simulated types from TestMonoBehaviour.cs
#endif

using UnityEngine;

/// <summary>
/// Test file containing INTENTIONAL Unity anti-patterns for analyzer testing.
/// DO NOT use as reference code - these are examples of what NOT to do.
/// Each anti-pattern is documented with the expected diagnostic ID.
/// </summary>
public class TestPatterns : MonoBehaviour
{
    private Transform cachedTransform;

    /// <summary>
    /// UNT0002: Inefficient tag comparison.
    /// Should use CompareTag() instead of == operator.
    /// </summary>
    void CheckTagBad()
    {
        // BAD: Direct string comparison (UNT0002)
        if (gameObject.tag == "Player") { }

        // GOOD: Using CompareTag
        // if (gameObject.CompareTag("Player")) { }
    }

    /// <summary>
    /// UNT0010: MonoBehaviour created with new.
    /// MonoBehaviours should be added with AddComponent.
    /// </summary>
    void CreateBehaviourBad()
    {
        // BAD: Using new to create MonoBehaviour (UNT0010)
        var mb = new TestPatterns();

        // GOOD: Using AddComponent
        // var mb = gameObject.AddComponent<TestPatterns>();
    }

    /// <summary>
    /// ULSM0001: Expensive call in hot path (Update).
    /// GetComponent should be cached in Awake/Start.
    /// </summary>
    void Update()
    {
        // BAD: GetComponent called every frame (ULSM0001)
        var rb = GetComponent<Transform>();

        // BAD: Camera.main called every frame (ULSM0004)
        var cam = Camera.main;

        // BAD: String interpolation in Update (ULSM0002)
        var message = $"Position: {transform}";

        // BAD: Debug.Log in Update (ULSM0003)
        Debug.Log(message);

        // GOOD: Use cached references
        // var rb = cachedTransform;
    }

    /// <summary>
    /// ULSM0002: String concatenation in hot path.
    /// String operations allocate memory.
    /// </summary>
    void FixedUpdate()
    {
        // BAD: String concatenation (ULSM0002)
        var text = "Value: " + Time.ToString();

        // GOOD: Use StringBuilder or avoid in hot paths
    }

    /// <summary>
    /// Test method containing Input API (for migration testing).
    /// Legacy Input system deprecated in favor of new Input System.
    /// </summary>
    void CheckInput()
    {
        // Legacy Input API (deprecated)
        // var horizontal = Input.GetAxis("Horizontal");
        // var fire = Input.GetButton("Fire1");
        // var keyDown = Input.GetKey(KeyCode.Space);
    }

    /// <summary>
    /// UNT0001: Empty Unity message.
    /// Empty Update/FixedUpdate/etc methods waste performance.
    /// </summary>
    void LateUpdate()
    {
        // BAD: Empty Unity message (UNT0001)
    }

    /// <summary>
    /// Example with Find methods (expensive operations).
    /// </summary>
    void FindObjectsBad()
    {
        // BAD: Find methods are expensive (ULSM0001 in hot paths)
        // var player = GameObject.Find("Player");
        // var enemies = GameObject.FindObjectsOfType<TestPatterns>();
    }

    // Placeholder for simulated Time class
    private static class Time
    {
        public static new string ToString() => "0.0";
    }
}
```

---

### Task 6: Create Unit Tests

#### 6.1 UnityProjectDetector Tests

**File:** `tests/ULSM.Tests/Unit/UnityProjectDetectorTests.cs`

```csharp
namespace ULSM.Tests.Unit;

/// <summary>
/// Unit tests for UnityProjectDetector class.
/// Tests the heuristics for identifying Unity projects.
/// </summary>
[TestFixture]
[Category("Unit")]
public class UnityProjectDetectorTests
{
    /// <summary>
    /// Verifies that a solution with Assembly-CSharp.csproj is detected as Unity.
    /// </summary>
    [Test]
    public void IsUnityProject_WithAssemblyCSharpProject_ReturnsTrue()
    {
        // Arrange
        TestPaths.SkipIfUnityTestProjectMissing();
        var solutionPath = TestPaths.UnityTestSolutionPath;

        // Act
        var result = UnityProjectDetector.IsUnityProject(solutionPath);

        // Assert
        Assert.That(result, Is.True,
            "Should detect Unity project by Assembly-CSharp.csproj presence");
    }

    /// <summary>
    /// Verifies that the main ULSM solution is NOT detected as Unity.
    /// </summary>
    [Test]
    public void IsUnityProject_WithStandardDotNetSolution_ReturnsFalse()
    {
        // Arrange
        var solutionPath = TestPaths.MainSolutionPath;

        // Act
        var result = UnityProjectDetector.IsUnityProject(solutionPath);

        // Assert
        Assert.That(result, Is.False,
            "Should not detect standard .NET project as Unity");
    }

    /// <summary>
    /// Verifies that Unity version is extracted from ProjectVersion.txt.
    /// </summary>
    [Test]
    public void GetUnityVersion_WithProjectVersionFile_ReturnsVersion()
    {
        // Arrange
        TestPaths.SkipIfUnityTestProjectMissing();
        var projectPath = TestPaths.UnityTestProjectPath;

        // Act
        var version = UnityProjectDetector.GetUnityVersion(projectPath);

        // Assert
        Assert.That(version, Is.Not.Null.And.Not.Empty,
            "Should extract Unity version from ProjectVersion.txt");
        Assert.That(version, Does.Contain("6000"),
            "Version should contain Unity 6 identifier");
    }

    /// <summary>
    /// Verifies that null is returned when no ProjectVersion.txt exists.
    /// </summary>
    [Test]
    public void GetUnityVersion_WithoutProjectVersionFile_ReturnsNull()
    {
        // Arrange
        var nonUnityPath = Path.GetDirectoryName(TestPaths.MainSolutionPath);

        // Act
        var version = UnityProjectDetector.GetUnityVersion(nonUnityPath!);

        // Assert
        Assert.That(version, Is.Null,
            "Should return null when ProjectVersion.txt is missing");
    }

    /// <summary>
    /// Verifies detection works with directory containing Assets and ProjectSettings.
    /// </summary>
    [Test]
    public void IsUnityProject_WithUnityFolderStructure_ReturnsTrue()
    {
        // Arrange
        TestPaths.SkipIfUnityTestProjectMissing();
        var solutionPath = TestPaths.UnityTestSolutionPath;

        // Act
        var result = UnityProjectDetector.IsUnityProject(solutionPath);

        // Assert
        Assert.That(result, Is.True,
            "Should detect Unity project by folder structure (Assets + ProjectSettings)");
    }

    /// <summary>
    /// Verifies graceful handling of non-existent paths.
    /// </summary>
    [Test]
    public void IsUnityProject_WithNonExistentPath_ReturnsFalse()
    {
        // Arrange
        var fakePath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString(), "Fake.sln");

        // Act
        var result = UnityProjectDetector.IsUnityProject(fakePath);

        // Assert
        Assert.That(result, Is.False,
            "Should return false for non-existent paths without throwing");
    }
}
```

#### 6.2 UnityWorkspaceLoader Tests

**File:** `tests/ULSM.Tests/Unit/UnityWorkspaceLoaderTests.cs`

```csharp
namespace ULSM.Tests.Unit;

/// <summary>
/// Unit tests for UnityWorkspaceLoader class.
/// Tests MSBuild configuration and framework path resolution.
/// </summary>
[TestFixture]
[Category("Unit")]
public class UnityWorkspaceLoaderTests
{
    /// <summary>
    /// Verifies that framework path resolution finds a valid path on Windows.
    /// </summary>
    [Test]
    [Platform("Win")]
    [Category("Platform")]
    public void GetFrameworkPath_OnWindows_ReturnsValidPath()
    {
        // Act
        var frameworkPath = UnityWorkspaceLoader.GetFrameworkPath();

        // Assert
        if (string.IsNullOrEmpty(frameworkPath))
        {
            Assert.Ignore(".NET Framework reference assemblies not installed on this system");
        }

        Assert.That(Directory.Exists(frameworkPath), Is.True,
            "Framework path should exist on disk");
        Assert.That(File.Exists(Path.Combine(frameworkPath, "mscorlib.dll")), Is.True,
            "Framework path should contain mscorlib.dll");
    }

    /// <summary>
    /// Verifies that framework path resolution finds a valid path on macOS/Linux.
    /// </summary>
    [Test]
    [Platform("Unix")]
    [Category("Platform")]
    public void GetFrameworkPath_OnUnix_ReturnsValidPathOrEmpty()
    {
        // Act
        var frameworkPath = UnityWorkspaceLoader.GetFrameworkPath();

        // Assert - On Unix, Mono may not be installed
        if (string.IsNullOrEmpty(frameworkPath))
        {
            Assert.Pass("Mono framework not installed - acceptable for CI without Unity");
        }

        Assert.That(Directory.Exists(frameworkPath), Is.True,
            "If framework path is returned, it should exist");
    }

    /// <summary>
    /// Verifies that environment variable override for framework path is respected.
    /// </summary>
    [Test]
    public void GetFrameworkPath_WithEnvironmentOverride_UsesOverride()
    {
        // Arrange
        var customPath = Path.Combine(Path.GetTempPath(), "CustomFramework");
        Directory.CreateDirectory(customPath);
        var originalValue = Environment.GetEnvironmentVariable("ULSM_FRAMEWORK_PATH");

        try
        {
            Environment.SetEnvironmentVariable("ULSM_FRAMEWORK_PATH", customPath);

            // Act
            var frameworkPath = UnityWorkspaceLoader.GetFrameworkPath();

            // Assert
            Assert.That(frameworkPath, Is.EqualTo(customPath),
                "Should use environment variable override");
        }
        finally
        {
            // Cleanup
            Environment.SetEnvironmentVariable("ULSM_FRAMEWORK_PATH", originalValue);
            Directory.Delete(customPath);
        }
    }

    /// <summary>
    /// Verifies that GetMSBuildProperties returns required Unity properties.
    /// </summary>
    [Test]
    public void GetMSBuildProperties_ReturnsRequiredProperties()
    {
        // Act
        var properties = UnityWorkspaceLoader.GetMSBuildProperties();

        // Assert
        Assert.That(properties, Does.ContainKey("MSBuildToolsVersion"),
            "Should include MSBuildToolsVersion property");
        Assert.That(properties, Does.ContainKey("RestorePackages"),
            "Should include RestorePackages property");
        Assert.That(properties["RestorePackages"], Is.EqualTo("false"),
            "RestorePackages should be disabled for Unity projects");
    }
}
```

#### 6.3 UnityAnalyzerLoader Tests

**File:** `tests/ULSM.Tests/Unit/UnityAnalyzerLoaderTests.cs`

```csharp
using Microsoft.CodeAnalysis.Diagnostics;

namespace ULSM.Tests.Unit;

/// <summary>
/// Unit tests for UnityAnalyzerLoader class.
/// Tests analyzer loading, caching, and category filtering.
/// </summary>
[TestFixture]
[Category("Unit")]
public class UnityAnalyzerLoaderTests
{
    [SetUp]
    public void Setup()
    {
        // Clear cache before each test to ensure isolation
        UnityAnalyzerLoader.ClearCache();
    }

    /// <summary>
    /// Verifies that LoadAllAnalyzers returns analyzers when package is available.
    /// </summary>
    [Test]
    public void LoadAllAnalyzers_WhenPackageAvailable_ReturnsAnalyzers()
    {
        // Act
        var analyzers = UnityAnalyzerLoader.LoadAllAnalyzers();

        // Assert
        // Note: May return empty if Microsoft.Unity.Analyzers is not loaded
        Assert.That(analyzers, Is.Not.Null,
            "Should return non-null array even if no analyzers found");
    }

    /// <summary>
    /// Verifies that caching works - second call returns same instance.
    /// </summary>
    [Test]
    public void LoadAllAnalyzers_CalledTwice_ReturnsCachedResult()
    {
        // Act
        var first = UnityAnalyzerLoader.LoadAllAnalyzers();
        var second = UnityAnalyzerLoader.LoadAllAnalyzers();

        // Assert
        Assert.That(ReferenceEquals(first, second), Is.False,
            "ImmutableArray is a struct, not same reference");
        Assert.That(first.Length, Is.EqualTo(second.Length),
            "Cached result should have same count");
    }

    /// <summary>
    /// Verifies that ClearCache actually clears the cache.
    /// </summary>
    [Test]
    public void ClearCache_AfterLoad_AllowsReload()
    {
        // Arrange
        var first = UnityAnalyzerLoader.LoadAllAnalyzers();

        // Act
        UnityAnalyzerLoader.ClearCache();
        var second = UnityAnalyzerLoader.LoadAllAnalyzers();

        // Assert
        Assert.That(first.Length, Is.EqualTo(second.Length),
            "Should return same analyzers after cache clear");
    }

    /// <summary>
    /// Verifies that GetAnalyzersByCategory with All returns all analyzers.
    /// </summary>
    [Test]
    public void GetAnalyzersByCategory_All_ReturnsAllAnalyzers()
    {
        // Arrange
        var all = UnityAnalyzerLoader.LoadAllAnalyzers();

        // Act
        var filtered = UnityAnalyzerLoader.GetAnalyzersByCategory(
            UnityAnalyzerLoader.AnalyzerCategory.All);

        // Assert
        Assert.That(filtered.Length, Is.EqualTo(all.Length),
            "Category.All should return all analyzers");
    }

    /// <summary>
    /// Verifies that GetAvailableDiagnostics returns diagnostic information.
    /// </summary>
    [Test]
    public void GetAvailableDiagnostics_ReturnsFormattedDiagnosticInfo()
    {
        // Act
        var diagnostics = UnityAnalyzerLoader.GetAvailableDiagnostics().ToList();

        // Assert
        Assert.That(diagnostics, Is.Not.Null,
            "Should return diagnostic information list");

        if (diagnostics.Count > 0)
        {
            var first = diagnostics[0];
            Assert.That(first, Has.Property("id"),
                "Diagnostic info should have id property");
            Assert.That(first, Has.Property("title"),
                "Diagnostic info should have title property");
        }
    }
}
```

#### 6.4 UnityPatternAnalyzer Tests

**File:** `tests/ULSM.Tests/Unit/UnityPatternAnalyzerTests.cs`

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace ULSM.Tests.Unit;

/// <summary>
/// Unit tests for UnityPatternAnalyzer class.
/// Tests custom pattern detection for Unity anti-patterns.
/// </summary>
[TestFixture]
[Category("Unit")]
public class UnityPatternAnalyzerTests
{
    private UnityPatternAnalyzer _analyzer;

    [SetUp]
    public void Setup()
    {
        _analyzer = new UnityPatternAnalyzer();
    }

    /// <summary>
    /// Verifies that GetComponent in Update is detected as ULSM0001.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_GetComponentInUpdate_ReturnsULSM0001()
    {
        // Arrange
        var code = @"
using UnityEngine;
public class TestClass : MonoBehaviour {
    void Update() {
        var comp = GetComponent<Transform>();
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        Assert.That(issues, Has.Some.Matches<UnityPatternAnalyzer.PatternIssue>(
            i => i.Id == "ULSM0001" && i.CodeSnippet.Contains("GetComponent")),
            "Should detect GetComponent in Update as ULSM0001");
    }

    /// <summary>
    /// Verifies that Camera.main in Update is detected as ULSM0004.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_CameraMainInUpdate_ReturnsULSM0004()
    {
        // Arrange
        var code = @"
using UnityEngine;
public class TestClass : MonoBehaviour {
    void Update() {
        var cam = Camera.main;
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        Assert.That(issues, Has.Some.Matches<UnityPatternAnalyzer.PatternIssue>(
            i => i.Id == "ULSM0004" && i.Severity == "Warning"),
            "Should detect Camera.main in Update as ULSM0004 Warning");
    }

    /// <summary>
    /// Verifies that string interpolation in Update is detected as ULSM0002.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_StringInterpolationInUpdate_ReturnsULSM0002()
    {
        // Arrange
        var code = @"
using UnityEngine;
public class TestClass : MonoBehaviour {
    void Update() {
        var msg = $""Time: {Time.deltaTime}"";
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        Assert.That(issues, Has.Some.Matches<UnityPatternAnalyzer.PatternIssue>(
            i => i.Id == "ULSM0002"),
            "Should detect string interpolation in Update as ULSM0002");
    }

    /// <summary>
    /// Verifies that Debug.Log in Update is detected as ULSM0003.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_DebugLogInUpdate_ReturnsULSM0003()
    {
        // Arrange
        var code = @"
using UnityEngine;
public class TestClass : MonoBehaviour {
    void Update() {
        Debug.Log(""test"");
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        Assert.That(issues, Has.Some.Matches<UnityPatternAnalyzer.PatternIssue>(
            i => i.Id == "ULSM0003"),
            "Should detect Debug.Log in Update as ULSM0003");
    }

    /// <summary>
    /// Verifies that patterns in non-hot-path methods are not flagged as warnings.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_GetComponentInStart_NotWarning()
    {
        // Arrange
        var code = @"
using UnityEngine;
public class TestClass : MonoBehaviour {
    void Start() {
        var comp = GetComponent<Transform>();
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        var getComponentIssues = issues.Where(i =>
            i.Id == "ULSM0001" && i.CodeSnippet.Contains("GetComponent"));
        Assert.That(getComponentIssues, Is.Empty,
            "Should not flag GetComponent in Start as it's not a hot path");
    }

    /// <summary>
    /// Verifies that non-MonoBehaviour classes are not analyzed.
    /// </summary>
    [Test]
    public async Task AnalyzeDocument_NonMonoBehaviour_ReturnsNoIssues()
    {
        // Arrange
        var code = @"
public class TestClass {
    void Update() {
        // This Update is not a Unity message
    }
}";
        var (document, semanticModel) = await CreateDocumentWithSemanticModelAsync(code);

        // Act
        var issues = await _analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Assert
        Assert.That(issues, Is.Empty,
            "Should not analyze non-MonoBehaviour classes");
    }

    /// <summary>
    /// Helper method to create a document with semantic model for testing.
    /// </summary>
    private async Task<(Document document, SemanticModel semanticModel)> CreateDocumentWithSemanticModelAsync(string code)
    {
        // Add Unity stub types
        var unityStubs = @"
namespace UnityEngine {
    public class Object { }
    public class Component : Object { }
    public class Behaviour : Component { }
    public class MonoBehaviour : Behaviour {
        public T GetComponent<T>() where T : Component => default;
        public GameObject gameObject => null;
        public Transform transform => null;
    }
    public class GameObject : Object { }
    public class Transform : Component { }
    public class Camera : Behaviour {
        public static Camera main => null;
    }
    public static class Time { public static float deltaTime => 0f; }
    public static class Debug {
        public static void Log(object msg) { }
    }
}
";
        var workspace = new AdhocWorkspace();
        var projectId = ProjectId.CreateNewId();
        var projectInfo = ProjectInfo.Create(
            projectId,
            VersionStamp.Default,
            "TestProject",
            "TestProject",
            LanguageNames.CSharp,
            parseOptions: new CSharpParseOptions(LanguageVersion.CSharp11));

        var project = workspace.AddProject(projectInfo);

        // Add Unity stubs
        var stubDoc = project.AddDocument("UnityStubs.cs", SourceText.From(unityStubs));
        project = stubDoc.Project;

        // Add test code
        var document = project.AddDocument("TestCode.cs", SourceText.From(code));
        var semanticModel = await document.GetSemanticModelAsync();

        return (document, semanticModel!);
    }
}
```

#### 6.5 UnityApiMigrationData Tests

**File:** `tests/ULSM.Tests/Unit/UnityApiMigrationDataTests.cs`

```csharp
namespace ULSM.Tests.Unit;

/// <summary>
/// Unit tests for UnityApiMigrationData class.
/// Tests the API deprecation database and version filtering.
/// </summary>
[TestFixture]
[Category("Unit")]
public class UnityApiMigrationDataTests
{
    /// <summary>
    /// Verifies that GetAllMigrations returns a non-empty list.
    /// </summary>
    [Test]
    public void GetAllMigrations_ReturnsNonEmptyList()
    {
        // Act
        var migrations = UnityApiMigrationData.GetAllMigrations();

        // Assert
        Assert.That(migrations, Is.Not.Null.And.Not.Empty,
            "Should return a list of API migrations");
        Assert.That(migrations.Count, Is.GreaterThan(10),
            "Should have substantial number of migration rules");
    }

    /// <summary>
    /// Verifies that each migration has required fields populated.
    /// </summary>
    [Test]
    public void GetAllMigrations_AllEntriesHaveRequiredFields()
    {
        // Act
        var migrations = UnityApiMigrationData.GetAllMigrations();

        // Assert
        foreach (var migration in migrations)
        {
            Assert.Multiple(() =>
            {
                Assert.That(migration.OldApi, Is.Not.Null.And.Not.Empty,
                    $"Migration should have OldApi");
                Assert.That(migration.NewApi, Is.Not.Null.And.Not.Empty,
                    $"Migration {migration.OldApi} should have NewApi");
                Assert.That(migration.Category, Is.Not.Null.And.Not.Empty,
                    $"Migration {migration.OldApi} should have Category");
                Assert.That(migration.MinVersion, Is.Not.Null.And.Not.Empty,
                    $"Migration {migration.OldApi} should have MinVersion");
            });
        }
    }

    /// <summary>
    /// Verifies that GetMigrationsForVersion filters correctly for Unity 6.
    /// </summary>
    [Test]
    public void GetMigrationsForVersion_Unity6_ReturnsRelevantMigrations()
    {
        // Act
        var migrations = UnityApiMigrationData.GetMigrationsForVersion("6000.0").ToList();

        // Assert
        Assert.That(migrations, Is.Not.Empty,
            "Should return migrations for Unity 6");
        Assert.That(migrations, Has.Some.Matches<UnityApiMigrationData.ApiMigration>(
            m => m.Category == "Networking"),
            "Should include Networking (UNet) deprecations for Unity 6");
    }

    /// <summary>
    /// Verifies that older version filters return fewer migrations.
    /// </summary>
    [Test]
    public void GetMigrationsForVersion_OlderVersion_ReturnsFewerMigrations()
    {
        // Arrange
        var unity6Migrations = UnityApiMigrationData.GetMigrationsForVersion("6000.0").ToList();
        var unity2019Migrations = UnityApiMigrationData.GetMigrationsForVersion("2019.4").ToList();

        // Assert
        Assert.That(unity2019Migrations.Count, Is.LessThanOrEqualTo(unity6Migrations.Count),
            "Older Unity version should have fewer or equal migrations");
    }

    /// <summary>
    /// Verifies that SearchByOldApi finds relevant migrations.
    /// </summary>
    [Test]
    public void SearchByOldApi_WithInputPattern_FindsInputMigrations()
    {
        // Act
        var inputMigrations = UnityApiMigrationData.SearchByOldApi("Input").ToList();

        // Assert
        Assert.That(inputMigrations, Is.Not.Empty,
            "Should find migrations related to Input");
        Assert.That(inputMigrations, Has.All.Matches<UnityApiMigrationData.ApiMigration>(
            m => m.OldApi.Contains("Input", StringComparison.OrdinalIgnoreCase)),
            "All results should contain 'Input' in OldApi");
    }

    /// <summary>
    /// Verifies that GetCategories returns distinct categories.
    /// </summary>
    [Test]
    public void GetCategories_ReturnsDistinctCategories()
    {
        // Act
        var categories = UnityApiMigrationData.GetCategories().ToList();

        // Assert
        Assert.That(categories, Is.Not.Empty,
            "Should return migration categories");
        Assert.That(categories, Is.Unique,
            "Categories should be distinct");
        Assert.That(categories, Does.Contain("Input"),
            "Should include Input category");
        Assert.That(categories, Does.Contain("Networking"),
            "Should include Networking category");
    }

    /// <summary>
    /// Verifies that version parsing handles various formats.
    /// </summary>
    [TestCase("6000.0", ExpectedResult = true)]
    [TestCase("6000.0.0", ExpectedResult = true)]
    [TestCase("2022.3", ExpectedResult = true)]
    [TestCase("2022.3.1f1", ExpectedResult = true)]
    [TestCase("2019.4.0", ExpectedResult = true)]
    public bool GetMigrationsForVersion_VariousFormats_ParsesCorrectly(string version)
    {
        // Act
        var migrations = UnityApiMigrationData.GetMigrationsForVersion(version);

        // Assert - Should not throw and should return something
        return migrations.Any();
    }
}
```

---

### Task 7: Create Integration Tests

**File:** `tests/ULSM.Tests/Integration/UnityProjectIntegrationTests.cs`

```csharp
namespace ULSM.Tests.Integration;

/// <summary>
/// Integration tests that load the actual Unity test project.
/// These tests verify end-to-end functionality of ULSM with Unity projects.
/// </summary>
[TestFixture]
[Category("Integration")]
public class UnityProjectIntegrationTests
{
    private RoslynService _service;

    [OneTimeSetUp]
    public async Task LoadUnityProject()
    {
        TestPaths.SkipIfUnityTestProjectMissing();

        _service = new RoslynService();

        try
        {
            var solutionPath = TestPaths.UnityTestSolutionPath;
            await _service.LoadSolutionAsync(solutionPath);
        }
        catch (Exception ex)
        {
            Assert.Ignore($"Could not load Unity test project: {ex.Message}");
        }
    }

    /// <summary>
    /// Verifies that the Unity test project loads successfully.
    /// </summary>
    [Test]
    [Order(1)]
    public async Task LoadSolution_UnityTestProject_LoadsSuccessfully()
    {
        // Act
        var health = await _service.GetHealthCheckAsync();

        // Assert
        Assert.That(health, Has.Property("status").EqualTo("Ready"),
            "Solution should be in Ready status");
    }

    /// <summary>
    /// Verifies that the health check reports Unity project detection.
    /// </summary>
    [Test]
    [Order(2)]
    public async Task GetHealthCheck_UnityProject_ReportsUnityStatus()
    {
        // Act
        var health = await _service.GetHealthCheckAsync();

        // Assert - Check for Unity-specific health info
        var healthJson = System.Text.Json.JsonSerializer.Serialize(health);
        Assert.That(healthJson, Does.Contain("Unity").IgnoreCase,
            "Health check should mention Unity project status");
    }

    /// <summary>
    /// Verifies that project count is at least 1 (Assembly-CSharp).
    /// </summary>
    [Test]
    [Order(3)]
    public async Task LoadSolution_UnityTestProject_HasExpectedProjectCount()
    {
        // Act
        var health = await _service.GetHealthCheckAsync();
        dynamic healthDynamic = health;

        // Assert
        Assert.That((int)healthDynamic.solution.projects, Is.GreaterThanOrEqualTo(1),
            "Should have at least 1 project loaded");
    }
}
```

**File:** `tests/ULSM.Tests/Integration/UnityAnalysisIntegrationTests.cs`

```csharp
namespace ULSM.Tests.Integration;

/// <summary>
/// Integration tests for Unity-specific analysis tools.
/// Tests the full pipeline from loading to analysis.
/// </summary>
[TestFixture]
[Category("Integration")]
public class UnityAnalysisIntegrationTests
{
    private RoslynService _roslynService;
    private UnityAnalysisService _analysisService;

    [OneTimeSetUp]
    public async Task Setup()
    {
        TestPaths.SkipIfUnityTestProjectMissing();

        _roslynService = new RoslynService();
        _analysisService = new UnityAnalysisService(_roslynService);

        try
        {
            await _roslynService.LoadSolutionAsync(TestPaths.UnityTestSolutionPath);
        }
        catch (Exception ex)
        {
            Assert.Ignore($"Could not load Unity test project: {ex.Message}");
        }
    }

    /// <summary>
    /// Verifies that GetAvailableDiagnostics returns information.
    /// </summary>
    [Test]
    public void GetAvailableDiagnostics_ReturnsAnalyzerInfo()
    {
        // Act
        var diagnostics = _analysisService.GetAvailableDiagnostics();

        // Assert
        Assert.That(diagnostics, Is.Not.Null,
            "Should return diagnostic information");
        Assert.That(diagnostics, Has.Property("customPatterns"),
            "Should include custom pattern information");
    }

    /// <summary>
    /// Verifies that CheckApiMigrationAsync finds deprecated APIs.
    /// </summary>
    [Test]
    public async Task CheckApiMigration_Unity6Target_ReturnsResults()
    {
        // Act
        var result = await _analysisService.CheckApiMigrationAsync(
            targetVersion: "6000.0");

        // Assert
        dynamic resultDynamic = result;
        Assert.That((bool)resultDynamic.success, Is.True,
            "API migration check should succeed");
        Assert.That((int)resultDynamic.migrationRulesChecked, Is.GreaterThan(0),
            "Should check migration rules");
    }

    /// <summary>
    /// Verifies that CheckUnityPatternsAsync analyzes files.
    /// </summary>
    [Test]
    public async Task CheckUnityPatterns_TestPatternsFile_FindsIssues()
    {
        // Arrange
        var testFile = TestPaths.GetUnityScriptPath("TestPatterns.cs");

        if (!File.Exists(testFile))
        {
            Assert.Ignore("TestPatterns.cs not found");
        }

        // Act
        var result = await _analysisService.CheckUnityPatternsAsync(testFile);

        // Assert
        dynamic resultDynamic = result;

        // If file is in solution, should find some issues
        if ((bool)resultDynamic.success)
        {
            Assert.That((int)resultDynamic.totalIssues, Is.GreaterThanOrEqualTo(0),
                "Should analyze file for patterns");
        }
    }
}
```

---

### Task 8: Update Solution File

**File:** `ULSM.sln` (modify existing)

Add the test project reference. The solution file needs to be updated to include the new ULSM.Tests project.

Add after the existing ULSM project entry:

```
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ULSM.Tests", "tests\ULSM.Tests\ULSM.Tests.csproj", "{B1234567-89AB-CDEF-0123-456789ABCDEF}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "tests", "tests", "{C2345678-9ABC-DEF0-1234-56789ABCDEF0}"
EndProject
```

Add to `GlobalSection(ProjectConfigurationPlatforms)`:

```
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|Any CPU.Build.0 = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|x64.ActiveCfg = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|x64.Build.0 = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|x86.ActiveCfg = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Debug|x86.Build.0 = Debug|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|Any CPU.ActiveCfg = Release|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|Any CPU.Build.0 = Release|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|x64.ActiveCfg = Release|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|x64.Build.0 = Release|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|x86.ActiveCfg = Release|Any CPU
{B1234567-89AB-CDEF-0123-456789ABCDEF}.Release|x86.Build.0 = Release|Any CPU
```

Add to `GlobalSection(NestedProjects)`:

```
{B1234567-89AB-CDEF-0123-456789ABCDEF} = {C2345678-9ABC-DEF0-1234-56789ABCDEF0}
```

**Alternatively**, use the `dotnet` CLI to add the project reference:

```bash
dotnet sln ULSM.sln add tests/ULSM.Tests/ULSM.Tests.csproj
```

---

### Task 9: Make Necessary API Additions

Some test files require public accessors that may not exist. Review and add as needed:

#### 9.1 UnityWorkspaceLoader.GetFrameworkPath

If `GetFrameworkPath` is private, expose it for testing:

```csharp
// In src/Unity/UnityWorkspaceLoader.cs

/// <summary>
/// Gets the framework path for Unity project loading.
/// Public for testing purposes.
/// </summary>
public static string GetFrameworkPath()
{
    // Check environment variable override first
    var envPath = Environment.GetEnvironmentVariable("ULSM_FRAMEWORK_PATH");
    if (!string.IsNullOrEmpty(envPath) && Directory.Exists(envPath))
        return envPath;

    // ... existing platform-specific logic
}

/// <summary>
/// Gets the MSBuild properties dictionary for Unity workspace configuration.
/// Public for testing purposes.
/// </summary>
public static Dictionary<string, string> GetMSBuildProperties()
{
    return new Dictionary<string, string>
    {
        ["MSBuildToolsVersion"] = "Current",
        ["FrameworkPathOverride"] = GetFrameworkPath(),
        ["RestorePackages"] = "false",
        ["SkipCopyBuildProduct"] = "true",
        ["SkipCopyFilesToOutputDirectory"] = "true",
    };
}
```

---

## Validation Checklist

### Build Validation

```bash
# Build entire solution including tests
dotnet build ULSM.sln

# Run all tests
dotnet test ULSM.sln

# Run only unit tests
dotnet test ULSM.sln --filter "Category=Unit"

# Run only integration tests
dotnet test ULSM.sln --filter "Category=Integration"

# Run with coverage
dotnet test ULSM.sln --collect:"XPlat Code Coverage"
```

### Expected Test Results

| Test Category | Expected Tests | Pass Criteria |
|---------------|----------------|---------------|
| Unit | 20+ | All pass |
| Integration | 5+ | Pass or skip (if Unity DLLs unavailable) |
| Platform | 2-4 | Platform-specific |

---

## Git Commit Strategy

### Commit 1: Create Test Project Structure

```bash
git add tests/ULSM.Tests/ULSM.Tests.csproj tests/ULSM.Tests/GlobalUsings.cs tests/ULSM.Tests/TestHelpers/
git commit -m "feat(tests): create ULSM.Tests project structure

- Add ULSM.Tests.csproj with NUnit 4.x and coverlet
- Add GlobalUsings.cs for common imports
- Add TestPaths helper for consistent path resolution"
```

### Commit 2: Create Unity Test Project

```bash
git add tests/UnityTestProject/
git commit -m "feat(tests): add minimal Unity test project

- Add Unity-style Assembly-CSharp.csproj (ToolsVersion 4.0)
- Add ProjectSettings/ProjectVersion.txt for version detection
- Add test scripts with intentional anti-patterns for analyzer testing
- Add simulated Unity types for standalone execution"
```

### Commit 3: Add Unit Tests

```bash
git add tests/ULSM.Tests/Unit/
git commit -m "feat(tests): add unit tests for Unity components

- Add UnityProjectDetectorTests (5 tests)
- Add UnityWorkspaceLoaderTests (4 tests)
- Add UnityAnalyzerLoaderTests (5 tests)
- Add UnityPatternAnalyzerTests (6 tests)
- Add UnityApiMigrationDataTests (6 tests)"
```

### Commit 4: Add Integration Tests

```bash
git add tests/ULSM.Tests/Integration/
git commit -m "feat(tests): add integration tests for Unity analysis

- Add UnityProjectIntegrationTests for project loading
- Add UnityAnalysisIntegrationTests for analysis tools
- Tests gracefully skip if Unity DLLs unavailable"
```

### Commit 5: Update Solution and Dependencies

```bash
git add ULSM.sln src/Unity/UnityWorkspaceLoader.cs
git commit -m "feat(tests): integrate test project into solution

- Add ULSM.Tests to ULSM.sln
- Expose GetFrameworkPath and GetMSBuildProperties for testing
- Add tests solution folder"
```

### Commit 6: Add Assignment Prompt

```bash
git add Prompts/PP13-106/
git commit -m "docs: add PP13-106 Phase 4 assignment prompt

Add comprehensive testing infrastructure implementation guide including
NUnit test project setup, Unity test project structure, and 25+ tests."
```

---

## Dev Diary Logging

### At Start

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-106
entry_type: plan
content: Starting Phase 4 implementation - Testing Infrastructure. Tasks: (1) Create tests/ULSM.Tests/ NUnit project with NUnit 4.x, (2) Create tests/UnityTestProject/ minimal Unity structure for integration testing, (3) Add TestPaths helper for consistent path resolution, (4) Implement unit tests for UnityProjectDetector, UnityWorkspaceLoader, UnityAnalyzerLoader, UnityPatternAnalyzer, UnityApiMigrationData, (5) Implement integration tests for project loading and analysis, (6) Update ULSM.sln with test project reference, (7) Expose necessary APIs for testing.
```

### During Implementation

Log at each major task completion with specific details about tests created and any challenges.

### On Completion

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-106
entry_type: work
content: Phase 4 complete. [Summary of tests created, coverage achieved, any deviations]
```

---

## Success Criteria

Phase 4 is complete when:

1. **Test Project Structure**
   - [ ] `tests/ULSM.Tests/` project created and builds
   - [ ] `tests/UnityTestProject/` minimal Unity project created
   - [ ] Solution includes test project

2. **Unit Tests**
   - [ ] UnityProjectDetectorTests (5+ tests)
   - [ ] UnityWorkspaceLoaderTests (4+ tests)
   - [ ] UnityAnalyzerLoaderTests (5+ tests)
   - [ ] UnityPatternAnalyzerTests (5+ tests)
   - [ ] UnityApiMigrationDataTests (5+ tests)

3. **Integration Tests**
   - [ ] UnityProjectIntegrationTests (3+ tests)
   - [ ] UnityAnalysisIntegrationTests (3+ tests)
   - [ ] Tests skip gracefully when Unity DLLs unavailable

4. **Build & Quality**
   - [ ] `dotnet build ULSM.sln` succeeds
   - [ ] `dotnet test ULSM.sln` runs without errors
   - [ ] Unit tests pass
   - [ ] Integration tests pass or skip appropriately

5. **Documentation**
   - [ ] Test categories documented
   - [ ] Test execution commands documented

---

## Next Phase

After completing PP13-106, proceed to:
- **PP13-107: Phase 5 - Documentation and Polish**

---

## Appendix A: NUnit Assert.That Examples

```csharp
// Equality
Assert.That(actual, Is.EqualTo(expected));
Assert.That(actual, Is.Not.EqualTo(unexpected));

// Null checks
Assert.That(value, Is.Null);
Assert.That(value, Is.Not.Null);

// Boolean
Assert.That(condition, Is.True);
Assert.That(condition, Is.False);

// Collections
Assert.That(collection, Is.Empty);
Assert.That(collection, Is.Not.Empty);
Assert.That(collection, Has.Count.EqualTo(5));
Assert.That(collection, Has.Some.Matches<T>(predicate));
Assert.That(collection, Has.All.Matches<T>(predicate));
Assert.That(collection, Does.Contain(item));

// Strings
Assert.That(str, Does.Contain("substring"));
Assert.That(str, Does.StartWith("prefix"));
Assert.That(str, Does.Match(@"regex"));
Assert.That(str, Is.Not.Null.And.Not.Empty);

// Numeric
Assert.That(value, Is.GreaterThan(5));
Assert.That(value, Is.InRange(1, 10));

// Type
Assert.That(obj, Is.InstanceOf<ExpectedType>());
Assert.That(obj, Has.Property("PropertyName"));

// Multiple assertions
Assert.Multiple(() =>
{
    Assert.That(a, Is.EqualTo(1));
    Assert.That(b, Is.EqualTo(2));
});
```

## Appendix B: Test Categories Reference

| Category | Attribute | When to Use |
|----------|-----------|-------------|
| Unit | `[Category("Unit")]` | Fast, isolated tests |
| Integration | `[Category("Integration")]` | Full system tests |
| Platform | `[Category("Platform")]` | OS-specific tests |

Use `[Platform("Win")]` or `[Platform("Unix")]` for platform-specific tests.

## Appendix C: Expected Directory Structure After Phase 4

```
ULSM/
├── src/
│   └── ... (existing files)
├── tests/
│   ├── ULSM.Tests/
│   │   ├── ULSM.Tests.csproj
│   │   ├── GlobalUsings.cs
│   │   ├── TestHelpers/
│   │   │   └── TestPaths.cs
│   │   ├── Unit/
│   │   │   ├── UnityProjectDetectorTests.cs
│   │   │   ├── UnityWorkspaceLoaderTests.cs
│   │   │   ├── UnityAnalyzerLoaderTests.cs
│   │   │   ├── UnityPatternAnalyzerTests.cs
│   │   │   └── UnityApiMigrationDataTests.cs
│   │   └── Integration/
│   │       ├── UnityProjectIntegrationTests.cs
│   │       └── UnityAnalysisIntegrationTests.cs
│   └── UnityTestProject/
│       ├── Assets/
│       │   └── Scripts/
│       │       ├── TestMonoBehaviour.cs
│       │       ├── TestScriptableObject.cs
│       │       └── TestPatterns.cs
│       ├── ProjectSettings/
│       │   └── ProjectVersion.txt
│       ├── Assembly-CSharp.csproj
│       └── UnityTestProject.sln
├── ULSM.sln
└── Documentation/
```
