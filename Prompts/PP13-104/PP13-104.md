# PP13-104: Phase 2 - Unity Workspace Loader

## Assignment Overview

| Field | Value |
|-------|-------|
| **Issue ID** | PP13-104 |
| **Parent Issue** | PP13-102 |
| **Depends On** | PP13-103 (Phase 1 - Completed) |
| **Phase** | 2 of 5 |
| **Title** | Unity Workspace Loader |
| **Reference** | [DevRoadmap.md](../../Documentation/tdd/DevRoadmap.md) - Phase 2 |
| **Technical Analysis** | [Unity-CSharp-LSP-MCP-Honest-Report.md](../../Documentation/tdd/Unity-CSharp-LSP-MCP-Honest-Report.md) |

---

## Objective

Enable ULSM to load Unity 6.x projects by creating a specialized workspace loader that handles Unity's legacy .csproj format (ToolsVersion 4.0), absolute HintPath DLL references, and platform-specific framework path resolution. The implementation must include an AdhocWorkspace fallback for when MSBuildWorkspace fails.

---

## Background: Why Unity Projects Are Different

Unity-generated .csproj files differ from standard .NET SDK-style projects:

1. **Legacy Format**: Uses `ToolsVersion="4.0"` instead of SDK-style `<Project Sdk="Microsoft.NET.Sdk">`
2. **Absolute HintPaths**: References like `<HintPath>C:/Program Files/Unity/Hub/Editor/6000.0.0f1/Editor/Data/Managed/UnityEngine/UnityEngine.dll</HintPath>`
3. **Mono/Framework Targeting**: Targets .NET Framework 4.7.1 via Mono, not .NET Core/6+
4. **Preprocessor Defines**: Contains Unity-specific defines like `UNITY_EDITOR`, `UNITY_6000_0_OR_NEWER`
5. **Project Naming**: Uses `Assembly-CSharp.csproj` and `Assembly-CSharp-Editor.csproj` conventions

The standard `MSBuildWorkspace.Create()` fails to load these projects without proper configuration.

---

## Pre-Implementation Checklist

Before starting implementation, verify:

- [ ] Read and understand `Prompts/BasePrompt.md` for project conventions
- [ ] Read `Documentation/tdd/DevRoadmap.md` Phase 2 section
- [ ] Read `Documentation/tdd/Unity-CSharp-LSP-MCP-Honest-Report.md` for technical context
- [ ] Verify dev-diary branch is `ULSM-PWS` (not `main`)
- [ ] Verify knowledge-agent branch is `ULSM-PWS` (not `main`)
- [ ] Verify PP13-103 commits are present (`git log --oneline -3`)
- [ ] `dotnet build ULSM.sln` succeeds on current codebase
- [ ] Create registry entry for PP13-104 in dev diary
- [ ] Log implementation plan in dev diary

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         RoslynService                            │
├─────────────────────────────────────────────────────────────────┤
│  LoadSolutionAsync(solutionPath)                                │
│    │                                                            │
│    ├─► UnityProjectDetector.IsUnityProject(solutionPath)        │
│    │                                                            │
│    ├─► IF Unity:                                                │
│    │     └─► UnityWorkspaceLoader.CreateWorkspaceAsync()        │
│    │           │                                                │
│    │           ├─► Try MSBuildWorkspace with Unity properties   │
│    │           │                                                │
│    │           └─► FALLBACK: UnityAdhocWorkspaceBuilder         │
│    │                                                            │
│    └─► ELSE (Standard .NET):                                    │
│          └─► MSBuildWorkspace.Create() (existing behavior)      │
└─────────────────────────────────────────────────────────────────┘
```

### New Files to Create

| File | Purpose |
|------|---------|
| `src/Unity/UnityProjectDetector.cs` | Detects if a solution/project is a Unity project |
| `src/Unity/UnityWorkspaceLoader.cs` | Creates MSBuildWorkspace with Unity-specific configuration |
| `src/Unity/UnityAdhocWorkspaceBuilder.cs` | Fallback workspace builder by parsing .csproj XML directly |
| `src/Unity/UnityWorkspaceUtility.cs` | Static utility functions for workspace operations |

### Files to Modify

| File | Changes |
|------|---------|
| `src/RoslynService.cs` | Integrate Unity detection and workspace loading in `LoadSolutionAsync` |
| `src/ULSM.csproj` | Add System.Xml.Linq reference for .csproj parsing |

---

## Implementation Tasks

### Task 1: Create Unity Folder Structure

Create the `src/Unity/` folder to contain all Unity-specific workspace loading code.

```bash
mkdir -p src/Unity
```

---

### Task 2: Implement UnityProjectDetector

**File:** `src/Unity/UnityProjectDetector.cs`

This static class detects whether a solution or project is a Unity project.

#### 2.1 Detection Criteria

A solution is detected as Unity if ANY of these conditions are true:
1. Contains `Assembly-CSharp.csproj` in the solution
2. Any .csproj contains `<HintPath>` referencing `UnityEngine.dll` or `UnityEditor.dll`
3. Solution's parent directory contains both `Assets/` and `ProjectSettings/` folders

#### 2.2 Implementation

```csharp
using System.Xml.Linq;

namespace ULSM.Unity;

/// <summary>
/// Detects whether a solution or project is a Unity-generated project.
/// Uses multiple heuristics including project naming, reference patterns, and folder structure.
/// </summary>
public static class UnityProjectDetector
{
    /// <summary>
    /// Determines if the given solution path points to a Unity project.
    /// </summary>
    /// <param name="solutionPath">Absolute path to the .sln file.</param>
    /// <returns>True if this is a Unity project, false otherwise.</returns>
    public static bool IsUnityProject(string solutionPath)
    {
        if (string.IsNullOrEmpty(solutionPath) || !File.Exists(solutionPath))
            return false;

        var solutionDir = Path.GetDirectoryName(solutionPath);
        if (string.IsNullOrEmpty(solutionDir))
            return false;

        // Check 1: Unity folder structure (Assets + ProjectSettings)
        if (HasUnityFolderStructure(solutionDir))
            return true;

        // Check 2: Assembly-CSharp.csproj presence
        if (HasAssemblyCSharpProject(solutionDir))
            return true;

        // Check 3: Any .csproj with Unity references
        if (HasUnityReferencesInAnyProject(solutionDir))
            return true;

        return false;
    }

    /// <summary>
    /// Checks for Unity's characteristic folder structure.
    /// </summary>
    private static bool HasUnityFolderStructure(string directory)
    {
        var assetsPath = Path.Combine(directory, "Assets");
        var projectSettingsPath = Path.Combine(directory, "ProjectSettings");
        return Directory.Exists(assetsPath) && Directory.Exists(projectSettingsPath);
    }

    /// <summary>
    /// Checks for Assembly-CSharp.csproj which Unity always generates.
    /// </summary>
    private static bool HasAssemblyCSharpProject(string directory)
    {
        var assemblyCSharpPath = Path.Combine(directory, "Assembly-CSharp.csproj");
        var assemblyCSharpEditorPath = Path.Combine(directory, "Assembly-CSharp-Editor.csproj");
        return File.Exists(assemblyCSharpPath) || File.Exists(assemblyCSharpEditorPath);
    }

    /// <summary>
    /// Scans .csproj files for Unity DLL references in HintPath elements.
    /// </summary>
    private static bool HasUnityReferencesInAnyProject(string directory)
    {
        var csprojFiles = Directory.GetFiles(directory, "*.csproj", SearchOption.TopDirectoryOnly);

        foreach (var csprojPath in csprojFiles)
        {
            if (HasUnityReferences(csprojPath))
                return true;
        }

        return false;
    }

    /// <summary>
    /// Checks a single .csproj file for Unity DLL references.
    /// </summary>
    /// <param name="csprojPath">Path to the .csproj file.</param>
    /// <returns>True if Unity references are found.</returns>
    public static bool HasUnityReferences(string csprojPath)
    {
        try
        {
            var xml = XDocument.Load(csprojPath);
            var hintPaths = xml.Descendants()
                .Where(e => e.Name.LocalName == "HintPath")
                .Select(e => e.Value);

            return hintPaths.Any(path =>
                path.Contains("UnityEngine.dll", StringComparison.OrdinalIgnoreCase) ||
                path.Contains("UnityEditor.dll", StringComparison.OrdinalIgnoreCase) ||
                path.Contains("Unity", StringComparison.OrdinalIgnoreCase) &&
                path.Contains("Managed", StringComparison.OrdinalIgnoreCase));
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Extracts Unity version from ProjectSettings/ProjectVersion.txt if present.
    /// </summary>
    /// <param name="solutionDir">Directory containing the Unity project.</param>
    /// <returns>Unity version string (e.g., "6000.0.0f1") or null if not found.</returns>
    public static string? GetUnityVersion(string solutionDir)
    {
        var versionFilePath = Path.Combine(solutionDir, "ProjectSettings", "ProjectVersion.txt");
        if (!File.Exists(versionFilePath))
            return null;

        try
        {
            var lines = File.ReadAllLines(versionFilePath);
            var editorVersionLine = lines.FirstOrDefault(l => l.StartsWith("m_EditorVersion:"));
            if (editorVersionLine != null)
            {
                return editorVersionLine.Replace("m_EditorVersion:", "").Trim();
            }
        }
        catch
        {
            // Ignore errors reading version file
        }

        return null;
    }
}
```

#### 2.3 Validation

- [ ] Method correctly identifies Unity projects by folder structure
- [ ] Method correctly identifies Unity projects by Assembly-CSharp.csproj
- [ ] Method correctly identifies Unity projects by HintPath references
- [ ] Method returns false for standard .NET projects
- [ ] GetUnityVersion extracts version from ProjectVersion.txt

---

### Task 3: Implement UnityWorkspaceLoader

**File:** `src/Unity/UnityWorkspaceLoader.cs`

This class creates an MSBuildWorkspace configured for Unity project loading.

#### 3.1 Key MSBuild Properties

| Property | Purpose |
|----------|---------|
| `MSBuildToolsVersion` | Set to "Current" to suppress ToolsVersion warnings |
| `FrameworkPathOverride` | Path to .NET Framework reference assemblies |
| `RestorePackages` | Set to "false" to prevent NuGet restore attempts |
| `SkipCopyBuildProduct` | Skip build outputs we don't need |
| `SkipCopyFilesToOutputDirectory` | Skip file copy operations |

#### 3.2 Framework Path Resolution

Unity targets .NET Framework 4.7.1. The framework path varies by platform:

| Platform | Typical Paths |
|----------|---------------|
| **Windows** | `C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.1` |
| **Windows (alt)** | `C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.8` |
| **macOS** | `/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.7.1-api` |
| **Linux** | `/usr/lib/mono/4.7.1-api` |

#### 3.3 Implementation

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace ULSM.Unity;

/// <summary>
/// Creates MSBuildWorkspace instances configured for Unity project loading.
/// Handles Unity's legacy ToolsVersion 4.0 .csproj format and platform-specific framework paths.
/// </summary>
public static class UnityWorkspaceLoader
{
    /// <summary>
    /// Creates an MSBuildWorkspace configured for Unity project loading.
    /// </summary>
    /// <param name="workspaceFailed">Optional callback for workspace failure events.</param>
    /// <returns>Configured MSBuildWorkspace instance.</returns>
    public static MSBuildWorkspace CreateWorkspace(Action<WorkspaceDiagnosticEventArgs>? workspaceFailed = null)
    {
        var properties = GetUnityMSBuildProperties();
        var workspace = MSBuildWorkspace.Create(properties);

        workspace.SkipUnrecognizedProjects = true;

        if (workspaceFailed != null)
        {
            workspace.WorkspaceFailed += (sender, args) => workspaceFailed(args);
        }

        return workspace;
    }

    /// <summary>
    /// Gets the MSBuild properties required for Unity project loading.
    /// </summary>
    /// <returns>Dictionary of MSBuild property name-value pairs.</returns>
    public static Dictionary<string, string> GetUnityMSBuildProperties()
    {
        var frameworkPath = FindFrameworkPath();

        var properties = new Dictionary<string, string>
        {
            // Suppress ToolsVersion warnings for legacy format
            ["MSBuildToolsVersion"] = "Current",

            // Prevent MSBuild from trying to restore packages
            ["RestorePackages"] = "false",

            // Skip targets that may fail outside Unity
            ["SkipCopyBuildProduct"] = "true",
            ["SkipCopyFilesToOutputDirectory"] = "true",
        };

        // Add framework path if found
        if (!string.IsNullOrEmpty(frameworkPath))
        {
            properties["FrameworkPathOverride"] = frameworkPath;
        }

        // Check for environment variable override
        var envFrameworkPath = Environment.GetEnvironmentVariable("ULSM_FRAMEWORK_PATH");
        if (!string.IsNullOrEmpty(envFrameworkPath))
        {
            properties["FrameworkPathOverride"] = envFrameworkPath;
        }

        return properties;
    }

    /// <summary>
    /// Finds the appropriate .NET Framework reference assemblies path for the current platform.
    /// Searches common installation locations and returns the first valid path found.
    /// </summary>
    /// <returns>Path to framework reference assemblies, or empty string if not found.</returns>
    public static string FindFrameworkPath()
    {
        // Check environment variable first
        var envPath = Environment.GetEnvironmentVariable("ULSM_FRAMEWORK_PATH");
        if (!string.IsNullOrEmpty(envPath) && Directory.Exists(envPath))
            return envPath;

        var searchPaths = GetPlatformFrameworkPaths();

        foreach (var path in searchPaths)
        {
            if (Directory.Exists(path))
            {
                // Verify it contains expected assemblies
                var mscorlibPath = Path.Combine(path, "mscorlib.dll");
                if (File.Exists(mscorlibPath))
                    return path;
            }
        }

        return string.Empty;
    }

    /// <summary>
    /// Gets the list of framework paths to search based on the current platform.
    /// </summary>
    private static string[] GetPlatformFrameworkPaths()
    {
        if (OperatingSystem.IsWindows())
        {
            return new[]
            {
                @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.1",
                @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.8",
                @"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1",
                @"C:\Windows\Microsoft.NET\Framework\v4.0.30319",
            };
        }
        else if (OperatingSystem.IsMacOS())
        {
            return new[]
            {
                "/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.7.1-api",
                "/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.8-api",
                "/Library/Frameworks/Mono.framework/Versions/Current/lib/mono/4.5",
            };
        }
        else // Linux
        {
            return new[]
            {
                "/usr/lib/mono/4.7.1-api",
                "/usr/lib/mono/4.8-api",
                "/usr/lib/mono/4.5",
                "/usr/share/dotnet/packs/Microsoft.NETFramework.ReferenceAssemblies.net471/1.0.0/build/.NETFramework/v4.7.1",
            };
        }
    }

    /// <summary>
    /// Loads a Unity solution with appropriate workspace configuration.
    /// Falls back to AdhocWorkspace if MSBuildWorkspace fails.
    /// </summary>
    /// <param name="solutionPath">Path to the Unity .sln file.</param>
    /// <param name="workspaceFailed">Optional callback for workspace failure events.</param>
    /// <returns>Tuple of (Workspace, Solution, usedFallback).</returns>
    public static async Task<(Workspace workspace, Solution solution, bool usedFallback)> LoadSolutionAsync(
        string solutionPath,
        Action<WorkspaceDiagnosticEventArgs>? workspaceFailed = null)
    {
        // Try MSBuildWorkspace first
        try
        {
            var workspace = CreateWorkspace(workspaceFailed);
            var solution = await workspace.OpenSolutionAsync(solutionPath);

            // Verify we actually loaded something
            if (solution.ProjectIds.Count > 0)
            {
                return (workspace, solution, false);
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ULSM Warning] MSBuildWorkspace failed: {ex.Message}");
        }

        // Fallback to AdhocWorkspace
        var forceAdhoc = Environment.GetEnvironmentVariable("ULSM_FORCE_ADHOC") == "true";
        if (forceAdhoc || true) // Always try fallback if MSBuild failed
        {
            Console.Error.WriteLine("[ULSM] Falling back to AdhocWorkspace");
            var (adhocWorkspace, adhocSolution) = await UnityAdhocWorkspaceBuilder.BuildFromSolutionAsync(solutionPath);
            return (adhocWorkspace, adhocSolution, true);
        }

        throw new InvalidOperationException("Failed to load Unity solution with both MSBuildWorkspace and AdhocWorkspace");
    }
}
```

#### 3.4 Validation

- [ ] CreateWorkspace returns valid MSBuildWorkspace
- [ ] GetUnityMSBuildProperties includes all required properties
- [ ] FindFrameworkPath returns valid path on Windows
- [ ] FindFrameworkPath returns valid path on macOS (if available)
- [ ] FindFrameworkPath returns valid path on Linux (if available)
- [ ] Environment variable override works
- [ ] LoadSolutionAsync falls back to AdhocWorkspace on failure

---

### Task 4: Implement UnityAdhocWorkspaceBuilder

**File:** `src/Unity/UnityAdhocWorkspaceBuilder.cs`

This class builds a Roslyn workspace by manually parsing Unity .csproj files, bypassing MSBuild entirely.

#### 4.1 Why Fallback is Needed

MSBuildWorkspace may fail if:
- MSBuild/SDK is not properly installed
- Unity's legacy .csproj format causes parsing errors
- Platform-specific issues with MSBuild resolution

The AdhocWorkspace fallback gives complete control by directly parsing .csproj XML.

#### 4.2 Implementation

```csharp
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace ULSM.Unity;

/// <summary>
/// Builds an AdhocWorkspace by manually parsing Unity .csproj files.
/// Used as fallback when MSBuildWorkspace fails to load Unity projects.
/// </summary>
public static class UnityAdhocWorkspaceBuilder
{
    /// <summary>
    /// Builds an AdhocWorkspace from a Unity solution by parsing all referenced .csproj files.
    /// </summary>
    /// <param name="solutionPath">Path to the .sln file.</param>
    /// <returns>Tuple of (AdhocWorkspace, Solution).</returns>
    public static async Task<(AdhocWorkspace workspace, Solution solution)> BuildFromSolutionAsync(string solutionPath)
    {
        var solutionDir = Path.GetDirectoryName(solutionPath)!;
        var workspace = new AdhocWorkspace();

        // Parse solution file to find project references
        var projectPaths = ParseSolutionProjects(solutionPath);

        // Build each project
        var projectIdMap = new Dictionary<string, ProjectId>();

        foreach (var projectPath in projectPaths)
        {
            var fullPath = Path.IsPathRooted(projectPath)
                ? projectPath
                : Path.Combine(solutionDir, projectPath);

            if (!File.Exists(fullPath) || !fullPath.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                continue;

            var projectId = ProjectId.CreateNewId();
            projectIdMap[fullPath] = projectId;
        }

        // Now create projects with references
        foreach (var (projectPath, projectId) in projectIdMap)
        {
            await AddProjectToWorkspaceAsync(workspace, projectPath, projectId, projectIdMap);
        }

        return (workspace, workspace.CurrentSolution);
    }

    /// <summary>
    /// Parses a .sln file to extract project paths.
    /// </summary>
    private static List<string> ParseSolutionProjects(string solutionPath)
    {
        var projects = new List<string>();
        var lines = File.ReadAllLines(solutionPath);

        foreach (var line in lines)
        {
            // Match: Project("{...}") = "Name", "path.csproj", "{...}"
            if (line.StartsWith("Project("))
            {
                var parts = line.Split(',');
                if (parts.Length >= 2)
                {
                    var projectPath = parts[1].Trim().Trim('"');
                    if (projectPath.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                    {
                        projects.Add(projectPath);
                    }
                }
            }
        }

        return projects;
    }

    /// <summary>
    /// Adds a single project to the workspace by parsing its .csproj file.
    /// </summary>
    private static async Task AddProjectToWorkspaceAsync(
        AdhocWorkspace workspace,
        string csprojPath,
        ProjectId projectId,
        Dictionary<string, ProjectId> projectIdMap)
    {
        var projectDir = Path.GetDirectoryName(csprojPath)!;
        var projectName = Path.GetFileNameWithoutExtension(csprojPath);

        var (sourceFiles, references, defines) = ParseCsprojFile(csprojPath);

        // Create parse options with preprocessor defines
        var parseOptions = new CSharpParseOptions(
            LanguageVersion.CSharp9,
            DocumentationMode.Parse,
            SourceCodeKind.Regular,
            defines
        );

        // Create compilation options
        var compilationOptions = new CSharpCompilationOptions(
            OutputKind.DynamicallyLinkedLibrary,
            allowUnsafe: true
        );

        // Load metadata references
        var metadataReferences = new List<MetadataReference>();
        foreach (var refPath in references)
        {
            var fullRefPath = Path.IsPathRooted(refPath)
                ? refPath
                : Path.Combine(projectDir, refPath);

            if (File.Exists(fullRefPath))
            {
                try
                {
                    metadataReferences.Add(MetadataReference.CreateFromFile(fullRefPath));
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"[ULSM Warning] Failed to load reference {fullRefPath}: {ex.Message}");
                }
            }
        }

        // Create project info
        var projectInfo = ProjectInfo.Create(
            projectId,
            VersionStamp.Default,
            projectName,
            projectName,
            LanguageNames.CSharp,
            filePath: csprojPath,
            parseOptions: parseOptions,
            compilationOptions: compilationOptions,
            metadataReferences: metadataReferences
        );

        // Add project to workspace
        workspace.AddProject(projectInfo);

        // Add source documents
        foreach (var sourceFile in sourceFiles)
        {
            var fullSourcePath = Path.IsPathRooted(sourceFile)
                ? sourceFile
                : Path.Combine(projectDir, sourceFile);

            if (File.Exists(fullSourcePath))
            {
                try
                {
                    var sourceText = SourceText.From(await File.ReadAllTextAsync(fullSourcePath));
                    var documentId = DocumentId.CreateNewId(projectId);
                    var documentInfo = DocumentInfo.Create(
                        documentId,
                        Path.GetFileName(fullSourcePath),
                        filePath: fullSourcePath,
                        loader: TextLoader.From(TextAndVersion.Create(sourceText, VersionStamp.Default))
                    );
                    workspace.AddDocument(documentInfo);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"[ULSM Warning] Failed to load source file {fullSourcePath}: {ex.Message}");
                }
            }
        }
    }

    /// <summary>
    /// Parses a Unity .csproj file to extract source files, references, and defines.
    /// </summary>
    /// <returns>Tuple of (sourceFiles, references, defines).</returns>
    public static (List<string> sourceFiles, List<string> references, IEnumerable<string> defines) ParseCsprojFile(string csprojPath)
    {
        var sourceFiles = new List<string>();
        var references = new List<string>();
        var defines = new List<string>();

        try
        {
            var xml = XDocument.Load(csprojPath);

            // Extract source files from <Compile Include="...">
            sourceFiles.AddRange(
                xml.Descendants()
                    .Where(e => e.Name.LocalName == "Compile")
                    .Select(e => e.Attribute("Include")?.Value)
                    .Where(v => !string.IsNullOrEmpty(v) && v.EndsWith(".cs", StringComparison.OrdinalIgnoreCase))!
            );

            // Extract references from <HintPath>
            references.AddRange(
                xml.Descendants()
                    .Where(e => e.Name.LocalName == "HintPath")
                    .Select(e => e.Value)
                    .Where(v => !string.IsNullOrEmpty(v))
            );

            // Extract preprocessor defines from <DefineConstants>
            var defineConstants = xml.Descendants()
                .FirstOrDefault(e => e.Name.LocalName == "DefineConstants");
            if (defineConstants != null && !string.IsNullOrEmpty(defineConstants.Value))
            {
                defines.AddRange(defineConstants.Value.Split(';', StringSplitOptions.RemoveEmptyEntries));
            }

            // Add common Unity defines if not present
            if (!defines.Contains("UNITY_EDITOR"))
            {
                defines.AddRange(new[]
                {
                    "UNITY_EDITOR",
                    "UNITY_2022_3_OR_NEWER",
                    "UNITY_6000_0_OR_NEWER"
                });
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ULSM Warning] Failed to parse {csprojPath}: {ex.Message}");
        }

        return (sourceFiles, references, defines);
    }
}
```

#### 4.3 Validation

- [ ] BuildFromSolutionAsync correctly parses .sln file
- [ ] ParseCsprojFile extracts all source files
- [ ] ParseCsprojFile extracts all HintPath references
- [ ] ParseCsprojFile extracts preprocessor defines
- [ ] Workspace loads valid documents
- [ ] MetadataReferences are loaded from HintPaths

---

### Task 5: Integrate into RoslynService

**File:** `src/RoslynService.cs`

Modify `LoadSolutionAsync` to detect Unity projects and use the appropriate loader.

#### 5.1 Add Using Statements

At the top of the file, add:
```csharp
using ULSM.Unity;
```

#### 5.2 Modify LoadSolutionAsync

Find the existing `LoadSolutionAsync` method and update it:

```csharp
/// <summary>
/// Loads a .NET solution for analysis. Automatically detects Unity projects and
/// configures the workspace appropriately.
/// </summary>
/// <param name="solutionPath">Absolute path to the .sln file.</param>
/// <returns>Solution loading result with project and document counts.</returns>
public async Task<object> LoadSolutionAsync(string solutionPath)
{
    if (!File.Exists(solutionPath))
    {
        throw new FileNotFoundException($"Solution file not found: {solutionPath}");
    }

    bool isUnityProject = UnityProjectDetector.IsUnityProject(solutionPath);
    bool usedFallback = false;
    string? unityVersion = null;

    if (isUnityProject)
    {
        var solutionDir = Path.GetDirectoryName(solutionPath);
        unityVersion = solutionDir != null ? UnityProjectDetector.GetUnityVersion(solutionDir) : null;

        Console.Error.WriteLine($"[ULSM] Detected Unity project" +
            (unityVersion != null ? $" (Unity {unityVersion})" : ""));

        var (workspace, solution, fallback) = await UnityWorkspaceLoader.LoadSolutionAsync(
            solutionPath,
            args =>
            {
                if (args.Diagnostic.Kind == WorkspaceDiagnosticKind.Warning)
                    Console.Error.WriteLine($"[ULSM Warning] Workspace: {args.Diagnostic.Message}");
            });

        _workspace = workspace as MSBuildWorkspace;
        _solution = solution;
        usedFallback = fallback;

        // For AdhocWorkspace, we need a different approach
        if (_workspace == null && workspace is AdhocWorkspace adhocWorkspace)
        {
            _solution = adhocWorkspace.CurrentSolution;
        }
    }
    else
    {
        // Standard .NET project loading (existing behavior)
        _workspace = MSBuildWorkspace.Create();
        _workspace.SkipUnrecognizedProjects = true;
        _workspace.WorkspaceFailed += (sender, args) =>
        {
            Console.Error.WriteLine($"[ULSM Warning] Workspace: {args.Diagnostic.Message}");
        };

        _solution = await _workspace.OpenSolutionAsync(solutionPath);
    }

    _documentCache.Clear();
    _solutionLoadedAt = DateTime.UtcNow;

    var projectCount = _solution.ProjectIds.Count;
    var documentCount = _solution.Projects.Sum(p => p.DocumentIds.Count);

    return new
    {
        success = true,
        solutionPath = _solution.FilePath,
        projectCount,
        documentCount,
        isUnityProject,
        unityVersion,
        usedFallback,
        loadedAt = _solutionLoadedAt?.ToString("yyyy-MM-ddTHH:mm:ssZ")
    };
}
```

#### 5.3 Add Private Field for AdhocWorkspace Support

Add a field to handle AdhocWorkspace scenarios:

```csharp
private Workspace? _workspaceBase; // For AdhocWorkspace fallback
```

And update relevant methods to use `_solution` which is workspace-agnostic.

#### 5.4 Validation

- [ ] Standard .NET projects load as before
- [ ] Unity projects are detected automatically
- [ ] Unity projects load with UnityWorkspaceLoader
- [ ] Fallback to AdhocWorkspace works when MSBuild fails
- [ ] Health check shows isUnityProject status
- [ ] Unity version is detected and reported

---

### Task 6: Update Health Check Response

**File:** `src/RoslynService.cs`

Update the `GetHealthCheckAsync` method to report Unity-specific status.

Add Unity-related fields to the health check response:

```csharp
public async Task<object> GetHealthCheckAsync()
{
    // ... existing null check ...

    var solutionDir = _solution.FilePath != null ? Path.GetDirectoryName(_solution.FilePath) : null;
    var isUnityProject = solutionDir != null && UnityProjectDetector.IsUnityProject(_solution.FilePath!);
    var unityVersion = solutionDir != null ? UnityProjectDetector.GetUnityVersion(solutionDir) : null;

    // ... existing diagnostics gathering ...

    return new
    {
        status = "Ready",
        message = "ULSM (Unity Language Server MCP) is operational",
        solution = new
        {
            loaded = true,
            path = _solution.FilePath,
            projects = projectCount,
            documents = documentCount,
            loadedAt = _solutionLoadedAt?.ToString("yyyy-MM-ddTHH:mm:ssZ"),
            errors = errorCount,
            warnings = warningCount,
            isUnityProject,       // NEW
            unityVersion          // NEW
        },
        workspace = new
        {
            indexed = true,
            cacheSize = _documentCache.Count,
            frameworkPath = UnityWorkspaceLoader.FindFrameworkPath()  // NEW
        },
        // ... rest of existing response ...
    };
}
```

---

### Task 7: Add Environment Variable Documentation

**File:** `src/server.json`

Update the environment section to document new Unity-specific variables:

```json
{
  "environment": {
    "DOTNET_SOLUTION_PATH": {
      "description": "Path to .sln file to auto-load on startup",
      "required": false
    },
    "ULSM_LOG_LEVEL": {
      "description": "Log level: Debug, Information, Warning, Error",
      "default": "Information"
    },
    "ULSM_MAX_DIAGNOSTICS": {
      "description": "Maximum diagnostics to return per request",
      "default": "100"
    },
    "ULSM_TIMEOUT_SECONDS": {
      "description": "Timeout for analysis operations",
      "default": "30"
    },
    "ULSM_FRAMEWORK_PATH": {
      "description": "Override path to .NET Framework reference assemblies (for Unity project loading)",
      "required": false
    },
    "ULSM_FORCE_ADHOC": {
      "description": "Force AdhocWorkspace instead of MSBuildWorkspace for Unity projects",
      "default": "false"
    },
    "UNITY_EDITOR_PATH": {
      "description": "Path to Unity Editor installation (used for reference resolution)",
      "required": false
    }
  }
}
```

---

## Validation Checklist

### Build Validation

```bash
# Clean and rebuild
dotnet clean ULSM.sln
dotnet restore ULSM.sln
dotnet build ULSM.sln

# Verify no build errors
# Verify no new build warnings related to Unity code
```

### Unit Test Validation

Create basic tests to verify the Unity detection and loading logic works.

### Manual Testing

If a Unity project is available:

```bash
# Set environment variable to Unity solution
$env:DOTNET_SOLUTION_PATH = "C:\path\to\UnityProject\UnityProject.sln"

# Run ULSM
dotnet run --project src/ULSM.csproj
```

Send test MCP requests:

```json
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}
```

```json
{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"ulsm:health_check","arguments":{}}}
```

Expected: Health check shows `isUnityProject: true` and Unity version if detected.

---

## Git Commit Strategy

### Commit 1: Unity Detection

```bash
git add src/Unity/UnityProjectDetector.cs
git commit -m "PP13-104: Add Unity project detection

- Create UnityProjectDetector class with multiple detection methods
- Check folder structure (Assets + ProjectSettings)
- Check for Assembly-CSharp.csproj
- Check for Unity DLL references in HintPaths
- Extract Unity version from ProjectVersion.txt"
```

### Commit 2: Unity Workspace Loader

```bash
git add src/Unity/UnityWorkspaceLoader.cs src/Unity/UnityAdhocWorkspaceBuilder.cs
git commit -m "PP13-104: Add Unity workspace loaders

- Create UnityWorkspaceLoader for MSBuildWorkspace configuration
- Configure Unity-specific MSBuild properties
- Platform-specific framework path resolution
- Create UnityAdhocWorkspaceBuilder as fallback
- Parse .csproj files directly for source files and references"
```

### Commit 3: Integration

```bash
git add src/RoslynService.cs src/server.json
git commit -m "PP13-104: Integrate Unity workspace loading into RoslynService

- Detect Unity projects automatically in LoadSolutionAsync
- Use UnityWorkspaceLoader for Unity projects
- Fallback to AdhocWorkspace when MSBuild fails
- Update health check with Unity-specific fields
- Document new environment variables in server.json"
```

---

## Dev Diary Logging

### At Start

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-104
entry_type: plan
content: Starting Phase 2 implementation - Unity Workspace Loader. Tasks: (1) Create UnityProjectDetector for Unity project identification, (2) Create UnityWorkspaceLoader with MSBuild configuration, (3) Create UnityAdhocWorkspaceBuilder fallback, (4) Integrate into RoslynService.LoadSolutionAsync, (5) Update health check response, (6) Document environment variables.
```

### During Implementation

Log at each major task completion.

### On Completion

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-104
entry_type: work
content: Phase 2 complete. [Summary of what was implemented and tested]
```

---

## Success Criteria

Phase 2 is complete when:

1. ✅ `UnityProjectDetector` correctly identifies Unity projects
2. ✅ `UnityWorkspaceLoader` creates workspace with Unity MSBuild properties
3. ✅ `UnityAdhocWorkspaceBuilder` parses .csproj files correctly
4. ✅ `FindFrameworkPath()` returns valid path on current platform
5. ✅ `LoadSolutionAsync` auto-detects and loads Unity projects
6. ✅ Fallback to AdhocWorkspace works when MSBuild fails
7. ✅ Health check reports `isUnityProject` and `unityVersion`
8. ✅ Environment variables documented in server.json
9. ✅ `dotnet build ULSM.sln` succeeds with no new errors
10. ✅ All commits follow project conventions

---

## Next Phase

After completing PP13-104, proceed to:
- **PP13-105: Phase 3 - Unity-Specific Analysis Tools** (Microsoft.Unity.Analyzers integration)

---

## Appendix A: Unity .csproj Reference

Typical Unity-generated .csproj structure:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>10.0.20506</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <RootNamespace></RootNamespace>
    <ProjectGuid>{GUID}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AssemblyName>Assembly-CSharp</AssemblyName>
    <TargetFrameworkVersion>v4.7.1</TargetFrameworkVersion>
    <DefineConstants>UNITY_2022_3_OR_NEWER;UNITY_6000;UNITY_6000_0_OR_NEWER;...</DefineConstants>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="UnityEngine">
      <HintPath>C:/Program Files/Unity/Hub/Editor/6000.0.0f1/Editor/Data/Managed/UnityEngine/UnityEngine.dll</HintPath>
    </Reference>
    <Reference Include="UnityEditor">
      <HintPath>C:/Program Files/Unity/Hub/Editor/6000.0.0f1/Editor/Data/Managed/UnityEditor.dll</HintPath>
    </Reference>
    <!-- More references... -->
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Assets/Scripts/MyScript.cs" />
    <!-- More source files... -->
  </ItemGroup>
</Project>
```

## Appendix B: Troubleshooting

| Issue | Cause | Solution |
|-------|-------|----------|
| "Framework path not found" | .NET Framework not installed | Install .NET Framework Targeting Pack or set `ULSM_FRAMEWORK_PATH` |
| "mscorlib.dll not found" | Invalid framework path | Verify the framework path contains mscorlib.dll |
| MSBuildWorkspace returns 0 projects | Unity .csproj parsing failed | Check logs for specific MSBuild errors, will fallback to AdhocWorkspace |
| UnityEngine namespace not resolved | HintPaths invalid | Ensure Unity is installed and .csproj HintPaths are correct |
| "No solution loaded" after load attempt | Both loaders failed | Check solution file exists and is valid |
