# PP13-105: Phase 3 - Unity-Specific Analysis Tools

## Assignment Overview

| Field | Value |
|-------|-------|
| **Issue ID** | PP13-105 |
| **Parent Issue** | PP13-102 |
| **Depends On** | PP13-104 (Phase 2 - Completed) |
| **Phase** | 3 of 5 |
| **Title** | Unity-Specific Analysis Tools |
| **Reference** | [DevRoadmap.md](../../Documentation/tdd/DevRoadmap.md) - Phase 3 |
| **Technical Analysis** | [Unity-CSharp-LSP-MCP-Honest-Report.md](../../Documentation/tdd/Unity-CSharp-LSP-MCP-Honest-Report.md) |

---

## Objective

Implement Unity-specific diagnostic and analysis tools that leverage Microsoft.Unity.Analyzers and custom pattern detection. These tools will provide Unity game developers with actionable insights about performance anti-patterns, deprecated API usage, and Unity-specific coding issues that generic C# analyzers cannot detect.

---

## Background: Why Unity-Specific Analysis Matters

### The Gap in Generic C# Analysis

Standard Roslyn analyzers are designed for general .NET applications. They miss Unity-specific issues:

1. **Null Comparison Semantics**: Unity overrides `==` operator for UnityEngine.Object - `null` checks behave differently than standard .NET
2. **Component Lifecycle**: MonoBehaviour methods like `Update()` and `Start()` have specific usage patterns
3. **Performance Hotspots**: `Update()` runs every frame; patterns acceptable elsewhere are costly here
4. **API Deprecations**: Unity 6.x deprecated many APIs; code that compiles may use obsolete patterns
5. **Memory Patterns**: `GetComponent()` allocations, string operations in hot paths, boxing

### Microsoft.Unity.Analyzers Coverage

The `Microsoft.Unity.Analyzers` package (currently v1.19.0) provides 50+ analyzers covering:

| ID Range | Category | Examples |
|----------|----------|----------|
| UNT0001-UNT0015 | Unity Messages | Empty messages, incorrect signatures, improper instantiation |
| UNT0016-UNT0025 | Null Checking | Null coalescing, null propagation on Unity objects |
| UNT0026-UNT0035 | Performance | Tag comparison, GetComponent in loops, string operations |
| USP0001-USP0020 | Suppressors | Suppress false positives from generic analyzers |

---

## Pre-Implementation Checklist

Before starting implementation, verify:

- [ ] Read and understand `Prompts/BasePrompt.md` for project conventions
- [ ] Read `Documentation/tdd/DevRoadmap.md` Phase 3 section completely
- [ ] Read `Documentation/tdd/Unity-CSharp-LSP-MCP-Honest-Report.md` for technical context
- [ ] Verify dev-diary branch is `ULSM-PWS` (not `main`)
- [ ] Verify knowledge-agent branch is `ULSM-PWS` (not `main`)
- [ ] Verify PP13-104 commits are present (`git log --oneline -5`)
- [ ] `dotnet build ULSM.sln` succeeds on current codebase
- [ ] Create registry entry for PP13-105 in dev diary
- [ ] Log implementation plan in dev diary

---

## Architecture Overview

### Phase 3 Component Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                           McpServer.cs                               │
├─────────────────────────────────────────────────────────────────────┤
│  HandleToolCallAsync()                                               │
│    ├─► "ulsm:unity_diagnostics"  → UnityAnalysisService              │
│    ├─► "ulsm:check_unity_patterns" → UnityAnalysisService            │
│    └─► "ulsm:api_migration"       → UnityAnalysisService             │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      UnityAnalysisService.cs                         │
├─────────────────────────────────────────────────────────────────────┤
│  + GetUnityDiagnosticsAsync(filePath?, projectPath?, options)       │
│  + CheckUnityPatternsAsync(filePath, options)                       │
│  + CheckApiMigrationAsync(filePath?, targetVersion)                 │
│  - LoadUnityAnalyzers() : ImmutableArray<DiagnosticAnalyzer>        │
│  - GetCompilationWithAnalyzers(project) : CompilationWithAnalyzers  │
│  - FormatUnityDiagnostic(diagnostic) : object                       │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                  src/Unity/Analyzers/                                │
├─────────────────────────────────────────────────────────────────────┤
│  UnityAnalyzerLoader.cs     - Loads Microsoft.Unity.Analyzers DLL   │
│  UnityPatternAnalyzer.cs    - Custom pattern detection logic        │
│  UnityApiMigrationData.cs   - Unity 6.x deprecation database        │
└─────────────────────────────────────────────────────────────────────┘
```

### File Organization

| File | Purpose | New/Modify |
|------|---------|------------|
| `src/ULSM.csproj` | Add Microsoft.Unity.Analyzers package reference | Modify |
| `src/Unity/Analyzers/UnityAnalyzerLoader.cs` | Load and manage Unity analyzer assemblies | New |
| `src/Unity/Analyzers/UnityPatternAnalyzer.cs` | Custom pattern detection beyond standard analyzers | New |
| `src/Unity/Analyzers/UnityApiMigrationData.cs` | Unity 6.x API deprecation mappings | New |
| `src/Unity/UnityAnalysisService.cs` | Main service orchestrating Unity analysis | New |
| `src/McpServer.cs` | Add 3 new tool definitions and handlers | Modify |
| `src/server.json` | Document new tools and their parameters | Modify |

---

## Implementation Tasks

### Task 1: Add NuGet Package Reference

**File:** `src/ULSM.csproj`

Add the Microsoft.Unity.Analyzers package:

```xml
<ItemGroup>
  <!-- Existing packages... -->

  <!-- Unity Analyzers -->
  <PackageReference Include="Microsoft.Unity.Analyzers" Version="1.19.0" />
</ItemGroup>
```

**Important Considerations:**
- This package contains `DiagnosticAnalyzer` implementations
- Analyzers are loaded reflectively at runtime
- The package also includes `DiagnosticSuppressor` types for false positive suppression

#### 1.1 Verification

After adding the package:

```bash
dotnet restore ULSM.sln
dotnet build ULSM.sln
```

Verify no build errors and the package is correctly referenced.

---

### Task 2: Implement UnityAnalyzerLoader

**File:** `src/Unity/Analyzers/UnityAnalyzerLoader.cs`

This class handles loading DiagnosticAnalyzer instances from the Microsoft.Unity.Analyzers assembly.

#### 2.1 Implementation

```csharp
using System.Collections.Immutable;
using System.Reflection;
using Microsoft.CodeAnalysis.Diagnostics;

namespace ULSM.Unity.Analyzers;

/// <summary>
/// Loads and manages Microsoft.Unity.Analyzers DiagnosticAnalyzer instances.
/// Provides filtered access to Unity-specific analyzers by category.
/// </summary>
public static class UnityAnalyzerLoader
{
    private static ImmutableArray<DiagnosticAnalyzer>? _cachedAnalyzers;
    private static readonly object _loadLock = new();

    /// <summary>
    /// Category filters for Unity analyzers.
    /// </summary>
    public enum AnalyzerCategory
    {
        All,
        Messages,       // UNT0001-UNT0015: Unity message issues
        NullChecking,   // UNT0016-UNT0025: Null handling issues
        Performance,    // UNT0026-UNT0035: Performance issues
        BestPractices   // UNT0036+: General best practices
    }

    /// <summary>
    /// Loads all Unity analyzers from the Microsoft.Unity.Analyzers assembly.
    /// Results are cached for subsequent calls.
    /// </summary>
    /// <returns>Immutable array of DiagnosticAnalyzer instances.</returns>
    public static ImmutableArray<DiagnosticAnalyzer> LoadAllAnalyzers()
    {
        if (_cachedAnalyzers.HasValue)
            return _cachedAnalyzers.Value;

        lock (_loadLock)
        {
            if (_cachedAnalyzers.HasValue)
                return _cachedAnalyzers.Value;

            var analyzers = LoadAnalyzersFromAssembly();
            _cachedAnalyzers = analyzers;
            return analyzers;
        }
    }

    /// <summary>
    /// Gets analyzers filtered by category based on diagnostic ID ranges.
    /// </summary>
    /// <param name="category">The category to filter by.</param>
    /// <returns>Filtered list of analyzers.</returns>
    public static ImmutableArray<DiagnosticAnalyzer> GetAnalyzersByCategory(AnalyzerCategory category)
    {
        if (category == AnalyzerCategory.All)
            return LoadAllAnalyzers();

        var allAnalyzers = LoadAllAnalyzers();
        var filtered = new List<DiagnosticAnalyzer>();

        foreach (var analyzer in allAnalyzers)
        {
            var diagnosticIds = analyzer.SupportedDiagnostics.Select(d => d.Id).ToList();

            bool matches = category switch
            {
                AnalyzerCategory.Messages => diagnosticIds.Any(id =>
                    id.StartsWith("UNT00") && int.TryParse(id.Substring(3), out var num) && num <= 15),
                AnalyzerCategory.NullChecking => diagnosticIds.Any(id =>
                    id.StartsWith("UNT00") && int.TryParse(id.Substring(3), out var num) && num >= 16 && num <= 25),
                AnalyzerCategory.Performance => diagnosticIds.Any(id =>
                    id.StartsWith("UNT00") && int.TryParse(id.Substring(3), out var num) && num >= 26 && num <= 35),
                AnalyzerCategory.BestPractices => diagnosticIds.Any(id =>
                    id.StartsWith("UNT00") && int.TryParse(id.Substring(3), out var num) && num >= 36),
                _ => false
            };

            if (matches)
                filtered.Add(analyzer);
        }

        return filtered.ToImmutableArray();
    }

    /// <summary>
    /// Loads analyzers by reflection from the Microsoft.Unity.Analyzers assembly.
    /// </summary>
    private static ImmutableArray<DiagnosticAnalyzer> LoadAnalyzersFromAssembly()
    {
        var analyzers = new List<DiagnosticAnalyzer>();

        try
        {
            // Find the assembly - it should be loaded via NuGet reference
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            var unityAnalyzerAssembly = assemblies.FirstOrDefault(a =>
                a.GetName().Name == "Microsoft.Unity.Analyzers");

            if (unityAnalyzerAssembly == null)
            {
                // Try to load explicitly if not already loaded
                try
                {
                    unityAnalyzerAssembly = Assembly.Load("Microsoft.Unity.Analyzers");
                }
                catch (FileNotFoundException)
                {
                    Console.Error.WriteLine("[ULSM Warning] Microsoft.Unity.Analyzers assembly not found");
                    return ImmutableArray<DiagnosticAnalyzer>.Empty;
                }
            }

            // Find all types that are DiagnosticAnalyzers
            var analyzerTypes = unityAnalyzerAssembly.GetTypes()
                .Where(t => typeof(DiagnosticAnalyzer).IsAssignableFrom(t)
                         && !t.IsAbstract
                         && t.GetConstructor(Type.EmptyTypes) != null);

            foreach (var type in analyzerTypes)
            {
                try
                {
                    if (Activator.CreateInstance(type) is DiagnosticAnalyzer analyzer)
                    {
                        analyzers.Add(analyzer);
                    }
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"[ULSM Warning] Failed to instantiate analyzer {type.Name}: {ex.Message}");
                }
            }

            Console.Error.WriteLine($"[ULSM] Loaded {analyzers.Count} Unity analyzers");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ULSM Error] Failed to load Unity analyzers: {ex.Message}");
        }

        return analyzers.ToImmutableArray();
    }

    /// <summary>
    /// Gets information about all available Unity diagnostics.
    /// Useful for documentation and discovery.
    /// </summary>
    /// <returns>List of diagnostic descriptors with metadata.</returns>
    public static IEnumerable<object> GetAvailableDiagnostics()
    {
        var analyzers = LoadAllAnalyzers();
        var diagnostics = new Dictionary<string, DiagnosticDescriptor>();

        foreach (var analyzer in analyzers)
        {
            foreach (var descriptor in analyzer.SupportedDiagnostics)
            {
                if (!diagnostics.ContainsKey(descriptor.Id))
                {
                    diagnostics[descriptor.Id] = descriptor;
                }
            }
        }

        return diagnostics.Values
            .OrderBy(d => d.Id)
            .Select(d => new
            {
                id = d.Id,
                title = d.Title.ToString(),
                description = d.Description.ToString(),
                category = d.Category,
                severity = d.DefaultSeverity.ToString(),
                helpLink = d.HelpLinkUri
            });
    }

    /// <summary>
    /// Clears the analyzer cache. Useful for testing or reloading.
    /// </summary>
    public static void ClearCache()
    {
        lock (_loadLock)
        {
            _cachedAnalyzers = null;
        }
    }
}
```

#### 2.2 Validation

- [ ] LoadAllAnalyzers returns non-empty array when package is installed
- [ ] GetAnalyzersByCategory correctly filters analyzers
- [ ] Caching works correctly (second call is faster)
- [ ] Graceful handling when assembly not found

---

### Task 3: Implement UnityPatternAnalyzer

**File:** `src/Unity/Analyzers/UnityPatternAnalyzer.cs`

Custom pattern analysis that goes beyond Microsoft.Unity.Analyzers coverage.

#### 3.1 Pattern Categories

| Pattern | Issue | Severity |
|---------|-------|----------|
| GetComponent in Update | Performance - allocation every frame | Warning |
| String concatenation in Update | Performance - GC allocation | Warning |
| Find* methods in runtime code | Performance - very slow operations | Warning |
| Boxing in hot paths | Performance - GC allocation | Info |
| Camera.main usage | Performance - FindObjectByTag internally | Info |
| SendMessage usage | Performance - reflection-based | Info |

#### 3.2 Implementation

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ULSM.Unity.Analyzers;

/// <summary>
/// Custom Unity pattern analyzer for detecting performance issues and anti-patterns
/// that are not covered by Microsoft.Unity.Analyzers.
/// </summary>
public class UnityPatternAnalyzer
{
    /// <summary>
    /// Represents a detected Unity pattern issue.
    /// </summary>
    public record PatternIssue(
        string Id,
        string Title,
        string Description,
        string Severity,  // Error, Warning, Info
        string Category,
        string FilePath,
        int Line,
        int Column,
        string CodeSnippet,
        string? Suggestion
    );

    /// <summary>
    /// Unity message methods that run frequently (hot paths).
    /// </summary>
    private static readonly HashSet<string> HotPathMethods = new(StringComparer.OrdinalIgnoreCase)
    {
        "Update", "LateUpdate", "FixedUpdate",
        "OnGUI", "OnRenderObject", "OnDrawGizmos",
        "OnTriggerStay", "OnCollisionStay"
    };

    /// <summary>
    /// Methods that involve expensive operations.
    /// </summary>
    private static readonly Dictionary<string, string> ExpensiveMethodPatterns = new()
    {
        ["GetComponent"] = "Cache component references in Awake/Start instead of calling every frame",
        ["GetComponentInChildren"] = "Cache component references in Awake/Start",
        ["GetComponentInParent"] = "Cache component references in Awake/Start",
        ["GetComponents"] = "Cache component array in Awake/Start",
        ["FindObjectOfType"] = "Use object references or singletons instead - extremely expensive",
        ["FindObjectsOfType"] = "Use object references or caching - extremely expensive",
        ["FindGameObjectWithTag"] = "Cache references in Awake/Start",
        ["FindGameObjectsWithTag"] = "Cache references or use object pooling",
        ["Find"] = "Use direct references or cached lookups instead of Find()",
        ["SendMessage"] = "Use direct method calls or events instead - uses reflection",
        ["BroadcastMessage"] = "Use direct method calls or events instead - uses reflection",
        ["SendMessageUpwards"] = "Use direct method calls or events instead - uses reflection"
    };

    /// <summary>
    /// Analyzes a syntax tree for Unity-specific patterns.
    /// </summary>
    /// <param name="document">The Roslyn document to analyze.</param>
    /// <param name="semanticModel">The semantic model for symbol resolution.</param>
    /// <returns>List of detected pattern issues.</returns>
    public async Task<List<PatternIssue>> AnalyzeDocumentAsync(Document document, SemanticModel semanticModel)
    {
        var issues = new List<PatternIssue>();
        var root = await document.GetSyntaxRootAsync();

        if (root == null)
            return issues;

        var filePath = document.FilePath ?? "unknown";

        // Find all class declarations that inherit from MonoBehaviour
        var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

        foreach (var classDecl in classes)
        {
            if (!InheritsFromMonoBehaviour(classDecl, semanticModel))
                continue;

            // Analyze methods within MonoBehaviour classes
            var methods = classDecl.DescendantNodes().OfType<MethodDeclarationSyntax>();

            foreach (var method in methods)
            {
                var methodName = method.Identifier.Text;
                var isHotPath = HotPathMethods.Contains(methodName);

                // Check for expensive calls in hot paths
                if (isHotPath)
                {
                    issues.AddRange(CheckExpensiveCallsInHotPath(method, filePath, semanticModel));
                    issues.AddRange(CheckStringConcatenationInHotPath(method, filePath));
                    issues.AddRange(CheckBoxingInHotPath(method, filePath, semanticModel));
                }

                // Check Camera.main usage anywhere
                issues.AddRange(CheckCameraMainUsage(method, filePath, isHotPath));
            }
        }

        return issues;
    }

    /// <summary>
    /// Checks if a class inherits from MonoBehaviour.
    /// </summary>
    private bool InheritsFromMonoBehaviour(ClassDeclarationSyntax classDecl, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetDeclaredSymbol(classDecl);
        if (symbol == null)
            return false;

        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == "MonoBehaviour" ||
                baseType.ToDisplayString().Contains("UnityEngine.MonoBehaviour"))
                return true;
            baseType = baseType.BaseType;
        }

        return false;
    }

    /// <summary>
    /// Detects expensive method calls in Unity hot path methods.
    /// </summary>
    private List<PatternIssue> CheckExpensiveCallsInHotPath(
        MethodDeclarationSyntax method,
        string filePath,
        SemanticModel semanticModel)
    {
        var issues = new List<PatternIssue>();
        var invocations = method.DescendantNodes().OfType<InvocationExpressionSyntax>();

        foreach (var invocation in invocations)
        {
            string? methodName = null;

            // Handle different invocation patterns
            if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
            {
                methodName = memberAccess.Name.Identifier.Text;
            }
            else if (invocation.Expression is IdentifierNameSyntax identifier)
            {
                methodName = identifier.Identifier.Text;
            }

            if (methodName != null && ExpensiveMethodPatterns.TryGetValue(methodName, out var suggestion))
            {
                var location = invocation.GetLocation();
                var lineSpan = location.GetLineSpan();

                issues.Add(new PatternIssue(
                    Id: "ULSM0001",
                    Title: $"Expensive call '{methodName}' in hot path",
                    Description: $"'{methodName}' is called in '{method.Identifier.Text}' which runs frequently. This can cause performance issues.",
                    Severity: "Warning",
                    Category: "Performance",
                    FilePath: filePath,
                    Line: lineSpan.StartLinePosition.Line,
                    Column: lineSpan.StartLinePosition.Character,
                    CodeSnippet: invocation.ToString(),
                    Suggestion: suggestion
                ));
            }
        }

        return issues;
    }

    /// <summary>
    /// Detects string concatenation in hot paths (causes GC allocation).
    /// </summary>
    private List<PatternIssue> CheckStringConcatenationInHotPath(
        MethodDeclarationSyntax method,
        string filePath)
    {
        var issues = new List<PatternIssue>();
        var binaryExpressions = method.DescendantNodes().OfType<BinaryExpressionSyntax>()
            .Where(b => b.IsKind(SyntaxKind.AddExpression));

        foreach (var expr in binaryExpressions)
        {
            // Check if this is string concatenation
            if (ContainsStringLiteral(expr.Left) || ContainsStringLiteral(expr.Right))
            {
                var location = expr.GetLocation();
                var lineSpan = location.GetLineSpan();

                issues.Add(new PatternIssue(
                    Id: "ULSM0002",
                    Title: "String concatenation in hot path",
                    Description: $"String concatenation in '{method.Identifier.Text}' allocates memory every frame.",
                    Severity: "Warning",
                    Category: "Performance",
                    FilePath: filePath,
                    Line: lineSpan.StartLinePosition.Line,
                    Column: lineSpan.StartLinePosition.Character,
                    CodeSnippet: expr.ToString(),
                    Suggestion: "Use StringBuilder, string.Format with cached values, or avoid string operations in Update"
                ));
            }
        }

        // Also check interpolated strings
        var interpolations = method.DescendantNodes().OfType<InterpolatedStringExpressionSyntax>();
        foreach (var interp in interpolations)
        {
            var location = interp.GetLocation();
            var lineSpan = location.GetLineSpan();

            issues.Add(new PatternIssue(
                Id: "ULSM0002",
                Title: "String interpolation in hot path",
                Description: $"String interpolation in '{method.Identifier.Text}' allocates memory every frame.",
                Severity: "Warning",
                Category: "Performance",
                FilePath: filePath,
                Line: lineSpan.StartLinePosition.Line,
                Column: lineSpan.StartLinePosition.Character,
                CodeSnippet: interp.ToString(),
                Suggestion: "Cache formatted strings or avoid string operations in Update"
            ));
        }

        return issues;
    }

    /// <summary>
    /// Detects potential boxing operations in hot paths.
    /// </summary>
    private List<PatternIssue> CheckBoxingInHotPath(
        MethodDeclarationSyntax method,
        string filePath,
        SemanticModel semanticModel)
    {
        var issues = new List<PatternIssue>();

        // Check for calls to methods that take object parameters with value types
        var invocations = method.DescendantNodes().OfType<InvocationExpressionSyntax>();

        foreach (var invocation in invocations)
        {
            // Check specifically for Debug.Log with value types (common boxing case)
            if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
            {
                if (memberAccess.Expression.ToString() == "Debug" &&
                    (memberAccess.Name.Identifier.Text == "Log" ||
                     memberAccess.Name.Identifier.Text == "LogWarning" ||
                     memberAccess.Name.Identifier.Text == "LogError"))
                {
                    var args = invocation.ArgumentList.Arguments;
                    foreach (var arg in args)
                    {
                        var typeInfo = semanticModel.GetTypeInfo(arg.Expression);
                        if (typeInfo.Type != null && typeInfo.Type.IsValueType)
                        {
                            var location = arg.GetLocation();
                            var lineSpan = location.GetLineSpan();

                            issues.Add(new PatternIssue(
                                Id: "ULSM0003",
                                Title: "Debug logging in hot path",
                                Description: $"Debug.Log in '{method.Identifier.Text}' should be removed or conditionally compiled for release builds.",
                                Severity: "Info",
                                Category: "Performance",
                                FilePath: filePath,
                                Line: lineSpan.StartLinePosition.Line,
                                Column: lineSpan.StartLinePosition.Character,
                                CodeSnippet: invocation.ToString(),
                                Suggestion: "Wrap in #if UNITY_EDITOR or [Conditional(\"UNITY_EDITOR\")] attribute, or remove for release"
                            ));
                            break; // One warning per Debug.Log call
                        }
                    }
                }
            }
        }

        return issues;
    }

    /// <summary>
    /// Detects Camera.main usage which calls FindObjectByTag internally.
    /// </summary>
    private List<PatternIssue> CheckCameraMainUsage(
        MethodDeclarationSyntax method,
        string filePath,
        bool isHotPath)
    {
        var issues = new List<PatternIssue>();
        var memberAccesses = method.DescendantNodes().OfType<MemberAccessExpressionSyntax>();

        foreach (var access in memberAccesses)
        {
            if (access.Expression.ToString() == "Camera" &&
                access.Name.Identifier.Text == "main")
            {
                var location = access.GetLocation();
                var lineSpan = location.GetLineSpan();

                issues.Add(new PatternIssue(
                    Id: "ULSM0004",
                    Title: "Camera.main usage",
                    Description: isHotPath
                        ? $"Camera.main in '{method.Identifier.Text}' calls FindObjectByTag every frame."
                        : "Camera.main calls FindObjectByTag internally. Consider caching the reference.",
                    Severity: isHotPath ? "Warning" : "Info",
                    Category: "Performance",
                    FilePath: filePath,
                    Line: lineSpan.StartLinePosition.Line,
                    Column: lineSpan.StartLinePosition.Character,
                    CodeSnippet: access.ToString(),
                    Suggestion: "Cache Camera.main reference in Awake/Start: private Camera _mainCamera; void Awake() => _mainCamera = Camera.main;"
                ));
            }
        }

        return issues;
    }

    /// <summary>
    /// Helper to check if an expression contains a string literal.
    /// </summary>
    private bool ContainsStringLiteral(ExpressionSyntax expr)
    {
        return expr is LiteralExpressionSyntax literal &&
               literal.IsKind(SyntaxKind.StringLiteralExpression);
    }
}
```

#### 3.3 Validation

- [ ] Detects GetComponent calls in Update methods
- [ ] Detects string concatenation in hot paths
- [ ] Detects Camera.main usage
- [ ] Provides actionable suggestions for each issue
- [ ] Correctly identifies MonoBehaviour-derived classes

---

### Task 4: Implement UnityApiMigrationData

**File:** `src/Unity/Analyzers/UnityApiMigrationData.cs`

Database of Unity API deprecations for migration checking.

#### 4.1 Implementation

```csharp
namespace ULSM.Unity.Analyzers;

/// <summary>
/// Database of Unity API deprecations and migrations.
/// Covers Unity 2022.x to Unity 6.x (6000.x) transitions.
/// </summary>
public static class UnityApiMigrationData
{
    /// <summary>
    /// Represents an API migration entry.
    /// </summary>
    public record ApiMigration(
        string OldApi,
        string NewApi,
        string MinVersion,       // Unity version where deprecated
        string RemovedVersion,   // Unity version where removed (or "Not Removed")
        string Category,
        string Notes
    );

    /// <summary>
    /// Get all known API deprecations/migrations.
    /// </summary>
    public static IReadOnlyList<ApiMigration> GetAllMigrations()
    {
        return _migrations;
    }

    /// <summary>
    /// Get migrations relevant for a specific Unity version.
    /// </summary>
    public static IEnumerable<ApiMigration> GetMigrationsForVersion(string targetVersion)
    {
        // Parse version to compare
        var targetParsed = ParseUnityVersion(targetVersion);

        return _migrations.Where(m =>
        {
            var minParsed = ParseUnityVersion(m.MinVersion);
            return CompareVersions(targetParsed, minParsed) >= 0;
        });
    }

    /// <summary>
    /// Search migrations by old API pattern.
    /// </summary>
    public static IEnumerable<ApiMigration> SearchByOldApi(string pattern)
    {
        return _migrations.Where(m =>
            m.OldApi.Contains(pattern, StringComparison.OrdinalIgnoreCase));
    }

    private static (int major, int minor, int patch) ParseUnityVersion(string version)
    {
        // Handle formats: "6000.0.0", "2022.3", "6000"
        var parts = version.Split('.', '-');
        int major = 0, minor = 0, patch = 0;

        if (parts.Length > 0) int.TryParse(parts[0], out major);
        if (parts.Length > 1) int.TryParse(parts[1], out minor);
        if (parts.Length > 2) int.TryParse(parts[2].TrimEnd('f', 'p', 'a', 'b'), out patch);

        return (major, minor, patch);
    }

    private static int CompareVersions((int major, int minor, int patch) a, (int major, int minor, int patch) b)
    {
        if (a.major != b.major) return a.major.CompareTo(b.major);
        if (a.minor != b.minor) return a.minor.CompareTo(b.minor);
        return a.patch.CompareTo(b.patch);
    }

    /// <summary>
    /// Database of Unity API migrations.
    /// Sources: Unity docs, upgrade guides, release notes.
    /// </summary>
    private static readonly List<ApiMigration> _migrations = new()
    {
        // ============ Input System ============
        new ApiMigration(
            "UnityEngine.Input.GetAxis",
            "UnityEngine.InputSystem.InputAction",
            "2019.4",
            "Not Removed",
            "Input",
            "Legacy Input Manager is deprecated. Use the new Input System package."
        ),
        new ApiMigration(
            "UnityEngine.Input.GetButton",
            "UnityEngine.InputSystem.InputAction",
            "2019.4",
            "Not Removed",
            "Input",
            "Legacy Input Manager is deprecated. Use the new Input System package."
        ),
        new ApiMigration(
            "UnityEngine.Input.GetKey",
            "UnityEngine.InputSystem.Keyboard.current",
            "2019.4",
            "Not Removed",
            "Input",
            "Legacy Input Manager is deprecated. Use the new Input System package."
        ),
        new ApiMigration(
            "UnityEngine.Input.GetMouseButton",
            "UnityEngine.InputSystem.Mouse.current",
            "2019.4",
            "Not Removed",
            "Input",
            "Legacy Input Manager is deprecated. Use the new Input System package."
        ),

        // ============ Physics ============
        new ApiMigration(
            "Physics.IgnoreCollision (layer overloads)",
            "Physics.IgnoreLayerCollision",
            "2022.3",
            "Not Removed",
            "Physics",
            "Use layer-based collision matrix settings instead"
        ),
        new ApiMigration(
            "Physics.autoSyncTransforms",
            "Physics.simulationMode",
            "2022.3",
            "Not Removed",
            "Physics",
            "Use Physics.simulationMode for controlling physics simulation"
        ),

        // ============ Rendering ============
        new ApiMigration(
            "Camera.SetTargetBuffers",
            "RenderTexture.SetRenderTarget",
            "2022.3",
            "Not Removed",
            "Rendering",
            "Use RenderTexture API or Scriptable Render Pipeline"
        ),
        new ApiMigration(
            "RenderTexture.GetTemporary (with int parameters)",
            "RenderTexture.GetTemporary (with RenderTextureDescriptor)",
            "2022.3",
            "Not Removed",
            "Rendering",
            "Use RenderTextureDescriptor overload for clarity"
        ),
        new ApiMigration(
            "Graphics.Blit (obsolete overloads)",
            "CommandBuffer.Blit",
            "2022.3",
            "Not Removed",
            "Rendering",
            "Use CommandBuffer API for better control and batching"
        ),

        // ============ UI ============
        new ApiMigration(
            "UnityEngine.UI (legacy)",
            "UnityEngine.UIElements",
            "2022.3",
            "Not Removed",
            "UI",
            "UI Toolkit (UIElements) is the recommended UI system for editor and runtime"
        ),

        // ============ Networking ============
        new ApiMigration(
            "UnityEngine.Networking.NetworkTransport",
            "Unity.Netcode.NetworkManager",
            "2022.3",
            "6000.0",
            "Networking",
            "UNet is removed in Unity 6. Use Netcode for GameObjects or third-party solution"
        ),
        new ApiMigration(
            "UnityEngine.Networking.NetworkManager",
            "Unity.Netcode.NetworkManager",
            "2022.3",
            "6000.0",
            "Networking",
            "UNet is removed in Unity 6. Use Netcode for GameObjects"
        ),

        // ============ WWW/Web ============
        new ApiMigration(
            "UnityEngine.WWW",
            "UnityEngine.Networking.UnityWebRequest",
            "2018.4",
            "2022.3",
            "Networking",
            "WWW class is removed. Use UnityWebRequest"
        ),

        // ============ ScriptableRenderPipeline ============
        new ApiMigration(
            "UnityEngine.Rendering.SRPBatcher (manual calls)",
            "Automatic batching",
            "2022.3",
            "Not Removed",
            "Rendering",
            "SRP Batcher is automatic in URP/HDRP; manual calls are deprecated"
        ),

        // ============ Unity 6 Specific ============
        new ApiMigration(
            "EditorUtility.DisplayDialog (some overloads)",
            "EditorUtility.DisplayDialog (updated signature)",
            "6000.0",
            "Not Removed",
            "Editor",
            "Some dialog overloads updated in Unity 6"
        ),
        new ApiMigration(
            "AssetDatabase.Refresh (synchronous)",
            "AssetDatabase.RefreshSettings",
            "6000.0",
            "Not Removed",
            "Editor",
            "Consider async refresh patterns in Unity 6"
        ),

        // ============ XR ============
        new ApiMigration(
            "UnityEngine.XR.WSA",
            "UnityEngine.XR.OpenXR",
            "2022.3",
            "6000.0",
            "XR",
            "Windows Mixed Reality API deprecated. Use OpenXR"
        ),
        new ApiMigration(
            "UnityEngine.VR.VRSettings",
            "UnityEngine.XR.XRSettings",
            "2019.4",
            "2022.3",
            "XR",
            "Legacy VR namespace removed. Use XR namespace"
        ),

        // ============ Coroutines/Async ============
        new ApiMigration(
            "StartCoroutine (string method name)",
            "StartCoroutine (IEnumerator)",
            "2019.4",
            "Not Removed",
            "Coroutines",
            "String-based coroutine start is slower due to reflection. Use IEnumerator overload"
        ),

        // ============ Audio ============
        new ApiMigration(
            "AudioSource.PlayScheduled",
            "AudioSource.PlayScheduled (with DSP time)",
            "2022.3",
            "Not Removed",
            "Audio",
            "Ensure using DSP time for accurate audio scheduling"
        ),

        // ============ Animation ============
        new ApiMigration(
            "Animation component (legacy)",
            "Animator component",
            "2017.4",
            "Not Removed",
            "Animation",
            "Legacy Animation component is deprecated. Use Animator with AnimatorController"
        ),

        // ============ Particle System ============
        new ApiMigration(
            "ParticleSystem.Emit (obsolete overloads)",
            "ParticleSystem.Emit (EmitParams)",
            "2022.3",
            "Not Removed",
            "Particles",
            "Use EmitParams struct for more control over emitted particles"
        ),
    };
}
```

#### 4.2 Validation

- [ ] GetAllMigrations returns complete list
- [ ] GetMigrationsForVersion filters correctly for Unity 6
- [ ] SearchByOldApi finds relevant migrations
- [ ] Version parsing handles various formats (6000.0, 2022.3.1f1)

---

### Task 5: Implement UnityAnalysisService

**File:** `src/Unity/UnityAnalysisService.cs`

The main service that orchestrates Unity analysis and exposes it to MCP tools.

#### 5.1 Implementation

```csharp
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using ULSM.Unity.Analyzers;

namespace ULSM.Unity;

/// <summary>
/// Service that provides Unity-specific code analysis capabilities.
/// Integrates Microsoft.Unity.Analyzers and custom pattern detection.
/// </summary>
public class UnityAnalysisService
{
    private readonly RoslynService _roslynService;

    public UnityAnalysisService(RoslynService roslynService)
    {
        _roslynService = roslynService;
    }

    /// <summary>
    /// Gets Unity-specific diagnostics for a file, project, or entire solution.
    /// Uses Microsoft.Unity.Analyzers to detect Unity anti-patterns.
    /// </summary>
    /// <param name="filePath">Optional: specific file to analyze.</param>
    /// <param name="projectPath">Optional: specific project to analyze.</param>
    /// <param name="category">Optional: filter by diagnostic category.</param>
    /// <param name="includeSuppressions">Include diagnostics that have suppressions.</param>
    /// <param name="maxResults">Maximum diagnostics to return (default: 100).</param>
    /// <returns>Unity diagnostics with detailed information.</returns>
    public async Task<object> GetUnityDiagnosticsAsync(
        string? filePath = null,
        string? projectPath = null,
        string? category = null,
        bool includeSuppressions = false,
        int maxResults = 100)
    {
        var solution = _roslynService.GetSolution();
        if (solution == null)
        {
            return new
            {
                success = false,
                error = "No solution loaded. Call ulsm:load_solution first."
            };
        }

        // Load Unity analyzers
        var analyzerCategory = category?.ToLowerInvariant() switch
        {
            "messages" => UnityAnalyzerLoader.AnalyzerCategory.Messages,
            "nullchecking" or "null" => UnityAnalyzerLoader.AnalyzerCategory.NullChecking,
            "performance" => UnityAnalyzerLoader.AnalyzerCategory.Performance,
            "bestpractices" or "practices" => UnityAnalyzerLoader.AnalyzerCategory.BestPractices,
            _ => UnityAnalyzerLoader.AnalyzerCategory.All
        };

        var analyzers = UnityAnalyzerLoader.GetAnalyzersByCategory(analyzerCategory);

        if (analyzers.Length == 0)
        {
            return new
            {
                success = false,
                error = "No Unity analyzers loaded. Ensure Microsoft.Unity.Analyzers package is installed."
            };
        }

        var allDiagnostics = new List<object>();
        var projectsAnalyzed = 0;
        var filesAnalyzed = 0;

        // Determine which projects to analyze
        IEnumerable<Project> projects = solution.Projects;
        if (!string.IsNullOrEmpty(projectPath))
        {
            projects = projects.Where(p =>
                p.FilePath?.Equals(projectPath, StringComparison.OrdinalIgnoreCase) == true ||
                p.Name.Equals(Path.GetFileNameWithoutExtension(projectPath), StringComparison.OrdinalIgnoreCase));
        }

        foreach (var project in projects)
        {
            var compilation = await project.GetCompilationAsync();
            if (compilation == null)
                continue;

            projectsAnalyzed++;

            // Run analyzers
            var compilationWithAnalyzers = compilation.WithAnalyzers(analyzers);
            var diagnostics = await compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync();

            // Filter by file if specified
            if (!string.IsNullOrEmpty(filePath))
            {
                diagnostics = diagnostics.Where(d =>
                    d.Location.SourceTree?.FilePath?.Equals(filePath, StringComparison.OrdinalIgnoreCase) == true)
                    .ToImmutableArray();
            }

            // Filter Unity-specific diagnostics (UNT* and USP*)
            var unityDiagnostics = diagnostics
                .Where(d => d.Id.StartsWith("UNT", StringComparison.OrdinalIgnoreCase) ||
                           d.Id.StartsWith("USP", StringComparison.OrdinalIgnoreCase))
                .ToList();

            foreach (var diagnostic in unityDiagnostics.Take(maxResults - allDiagnostics.Count))
            {
                var location = diagnostic.Location;
                var lineSpan = location.GetLineSpan();
                var sourceTree = location.SourceTree;

                if (sourceTree != null)
                    filesAnalyzed++;

                allDiagnostics.Add(new
                {
                    id = diagnostic.Id,
                    severity = diagnostic.Severity.ToString(),
                    message = diagnostic.GetMessage(),
                    category = diagnostic.Descriptor.Category,
                    title = diagnostic.Descriptor.Title.ToString(),
                    description = diagnostic.Descriptor.Description.ToString(),
                    helpLink = diagnostic.Descriptor.HelpLinkUri,
                    file = sourceTree?.FilePath,
                    line = lineSpan.StartLinePosition.Line,
                    column = lineSpan.StartLinePosition.Character,
                    endLine = lineSpan.EndLinePosition.Line,
                    endColumn = lineSpan.EndLinePosition.Character,
                    project = project.Name
                });

                if (allDiagnostics.Count >= maxResults)
                    break;
            }

            if (allDiagnostics.Count >= maxResults)
                break;
        }

        // Group by ID for summary
        var summary = allDiagnostics
            .GroupBy(d => ((dynamic)d).id as string)
            .Select(g => new { id = g.Key, count = g.Count() })
            .OrderByDescending(x => x.count)
            .ToList();

        return new
        {
            success = true,
            totalDiagnostics = allDiagnostics.Count,
            projectsAnalyzed,
            filesAnalyzed,
            analyzerCount = analyzers.Length,
            categoryFilter = category ?? "all",
            truncated = allDiagnostics.Count >= maxResults,
            summary,
            diagnostics = allDiagnostics
        };
    }

    /// <summary>
    /// Checks for Unity-specific performance patterns and anti-patterns.
    /// Goes beyond Microsoft.Unity.Analyzers with custom pattern detection.
    /// </summary>
    /// <param name="filePath">File to analyze.</param>
    /// <param name="includeInfo">Include informational patterns (default: true).</param>
    /// <param name="checkHotPathsOnly">Only check patterns in Update/FixedUpdate (default: false).</param>
    /// <returns>Pattern analysis results with suggestions.</returns>
    public async Task<object> CheckUnityPatternsAsync(
        string filePath,
        bool includeInfo = true,
        bool checkHotPathsOnly = false)
    {
        var solution = _roslynService.GetSolution();
        if (solution == null)
        {
            return new
            {
                success = false,
                error = "No solution loaded. Call ulsm:load_solution first."
            };
        }

        // Find the document
        Document? document = null;
        foreach (var project in solution.Projects)
        {
            document = project.Documents.FirstOrDefault(d =>
                d.FilePath?.Equals(filePath, StringComparison.OrdinalIgnoreCase) == true);
            if (document != null)
                break;
        }

        if (document == null)
        {
            return new
            {
                success = false,
                error = $"File not found in solution: {filePath}"
            };
        }

        var semanticModel = await document.GetSemanticModelAsync();
        if (semanticModel == null)
        {
            return new
            {
                success = false,
                error = "Could not get semantic model for file"
            };
        }

        // Run custom pattern analysis
        var analyzer = new UnityPatternAnalyzer();
        var issues = await analyzer.AnalyzeDocumentAsync(document, semanticModel);

        // Filter by severity if requested
        if (!includeInfo)
        {
            issues = issues.Where(i => i.Severity != "Info").ToList();
        }

        // Group by category
        var byCategory = issues
            .GroupBy(i => i.Category)
            .Select(g => new { category = g.Key, count = g.Count() })
            .ToList();

        // Group by ID
        var byId = issues
            .GroupBy(i => i.Id)
            .Select(g => new { id = g.Key, title = g.First().Title, count = g.Count() })
            .OrderByDescending(x => x.count)
            .ToList();

        return new
        {
            success = true,
            file = filePath,
            totalIssues = issues.Count,
            byCategory,
            byId,
            issues = issues.Select(i => new
            {
                i.Id,
                i.Title,
                i.Description,
                i.Severity,
                i.Category,
                i.Line,
                i.Column,
                i.CodeSnippet,
                i.Suggestion
            }).ToList()
        };
    }

    /// <summary>
    /// Checks for deprecated Unity API usage that should be migrated.
    /// </summary>
    /// <param name="filePath">Optional: specific file to check.</param>
    /// <param name="projectPath">Optional: specific project to check.</param>
    /// <param name="targetVersion">Unity version to check migrations for (default: 6000.0).</param>
    /// <param name="categoryFilter">Optional: filter by migration category.</param>
    /// <returns>API migration recommendations.</returns>
    public async Task<object> CheckApiMigrationAsync(
        string? filePath = null,
        string? projectPath = null,
        string targetVersion = "6000.0",
        string? categoryFilter = null)
    {
        var solution = _roslynService.GetSolution();
        if (solution == null)
        {
            return new
            {
                success = false,
                error = "No solution loaded. Call ulsm:load_solution first."
            };
        }

        // Get relevant migrations for target version
        var migrations = UnityApiMigrationData.GetMigrationsForVersion(targetVersion);
        if (!string.IsNullOrEmpty(categoryFilter))
        {
            migrations = migrations.Where(m =>
                m.Category.Equals(categoryFilter, StringComparison.OrdinalIgnoreCase));
        }

        var migrationList = migrations.ToList();
        var findings = new List<object>();
        var filesChecked = 0;
        var projectsChecked = 0;

        // Determine which projects to analyze
        IEnumerable<Project> projects = solution.Projects;
        if (!string.IsNullOrEmpty(projectPath))
        {
            projects = projects.Where(p =>
                p.FilePath?.Equals(projectPath, StringComparison.OrdinalIgnoreCase) == true ||
                p.Name.Equals(Path.GetFileNameWithoutExtension(projectPath), StringComparison.OrdinalIgnoreCase));
        }

        foreach (var project in projects)
        {
            projectsChecked++;

            IEnumerable<Document> documents = project.Documents;
            if (!string.IsNullOrEmpty(filePath))
            {
                documents = documents.Where(d =>
                    d.FilePath?.Equals(filePath, StringComparison.OrdinalIgnoreCase) == true);
            }

            foreach (var document in documents)
            {
                if (document.FilePath == null || !document.FilePath.EndsWith(".cs"))
                    continue;

                filesChecked++;
                var text = await document.GetTextAsync();
                var content = text.ToString();

                // Simple text-based search for deprecated APIs
                // (Full semantic analysis would be more accurate but also more expensive)
                foreach (var migration in migrationList)
                {
                    var searchTerm = ExtractSearchTerm(migration.OldApi);
                    if (string.IsNullOrEmpty(searchTerm))
                        continue;

                    var index = 0;
                    while ((index = content.IndexOf(searchTerm, index, StringComparison.Ordinal)) >= 0)
                    {
                        // Get line number
                        var linePosition = text.Lines.GetLinePosition(index);
                        var line = text.Lines[linePosition.Line];

                        findings.Add(new
                        {
                            oldApi = migration.OldApi,
                            newApi = migration.NewApi,
                            category = migration.Category,
                            deprecatedIn = migration.MinVersion,
                            removedIn = migration.RemovedVersion,
                            notes = migration.Notes,
                            file = document.FilePath,
                            line = linePosition.Line,
                            column = linePosition.Character,
                            codeSnippet = line.ToString().Trim()
                        });

                        index += searchTerm.Length;
                    }
                }
            }
        }

        // Group findings by API
        var byApi = findings
            .GroupBy(f => ((dynamic)f).oldApi as string)
            .Select(g => new { api = g.Key, count = g.Count() })
            .OrderByDescending(x => x.count)
            .ToList();

        // Group by category
        var byCategory = findings
            .GroupBy(f => ((dynamic)f).category as string)
            .Select(g => new { category = g.Key, count = g.Count() })
            .OrderByDescending(x => x.count)
            .ToList();

        return new
        {
            success = true,
            targetVersion,
            migrationRulesChecked = migrationList.Count,
            projectsChecked,
            filesChecked,
            totalFindings = findings.Count,
            byApi,
            byCategory,
            findings
        };
    }

    /// <summary>
    /// Gets list of available Unity diagnostics for discovery.
    /// </summary>
    public object GetAvailableDiagnostics()
    {
        var diagnostics = UnityAnalyzerLoader.GetAvailableDiagnostics().ToList();
        var migrations = UnityApiMigrationData.GetAllMigrations();

        return new
        {
            analyzerDiagnostics = diagnostics,
            analyzerCount = diagnostics.Count,
            customPatterns = new[]
            {
                new { id = "ULSM0001", title = "Expensive call in hot path", category = "Performance" },
                new { id = "ULSM0002", title = "String operation in hot path", category = "Performance" },
                new { id = "ULSM0003", title = "Debug logging in hot path", category = "Performance" },
                new { id = "ULSM0004", title = "Camera.main usage", category = "Performance" }
            },
            migrationRules = migrations.Count(),
            migrationCategories = migrations.Select(m => m.Category).Distinct().OrderBy(c => c).ToList()
        };
    }

    /// <summary>
    /// Extracts a searchable term from an API specification.
    /// </summary>
    private string ExtractSearchTerm(string apiSpec)
    {
        // Handle patterns like "UnityEngine.Input.GetAxis" -> "Input.GetAxis"
        // Or "Camera.main" -> "Camera.main"

        if (apiSpec.Contains("("))
            apiSpec = apiSpec.Substring(0, apiSpec.IndexOf("("));

        var parts = apiSpec.Split('.');

        // Return last two parts for better matching
        if (parts.Length >= 2)
            return $"{parts[^2]}.{parts[^1]}";

        return parts[^1];
    }
}
```

#### 5.2 Validation

- [ ] GetUnityDiagnosticsAsync returns diagnostics from Unity analyzers
- [ ] Category filtering works correctly
- [ ] CheckUnityPatternsAsync detects custom patterns
- [ ] CheckApiMigrationAsync finds deprecated API usage
- [ ] GetAvailableDiagnostics returns complete list

---

### Task 6: Add RoslynService.GetSolution() Method

**File:** `src/RoslynService.cs`

Add a public getter for the solution to allow UnityAnalysisService access.

#### 6.1 Add Method

Add this method to `RoslynService`:

```csharp
/// <summary>
/// Gets the currently loaded solution.
/// Used by UnityAnalysisService for analysis operations.
/// </summary>
/// <returns>The loaded Solution, or null if none loaded.</returns>
public Solution? GetSolution() => _solution;
```

---

### Task 7: Register New Tools in McpServer

**File:** `src/McpServer.cs`

Add the three new Unity analysis tools.

#### 7.1 Add Tool Definitions

In `HandleListToolsAsync`, add these tools to the `tools` list:

```csharp
// After existing tools in the list...

(object)new
{
    name = "ulsm:unity_diagnostics",
    description = "Get Unity-specific diagnostics using Microsoft.Unity.Analyzers. Detects Unity anti-patterns like null coalescing on Unity objects, inefficient tag comparison, empty Unity messages, and more. Requires a Unity project to be loaded.",
    inputSchema = new
    {
        type = "object",
        properties = new
        {
            filePath = new { type = "string", description = "Optional: analyze specific file only" },
            projectPath = new { type = "string", description = "Optional: analyze specific project only" },
            category = new { type = "string", description = "Optional: filter by category - 'messages', 'nullchecking', 'performance', or 'bestpractices'" },
            includeSuppressions = new { type = "boolean", description = "Include suppressed diagnostics (default: false)" },
            maxResults = new { type = "integer", description = "Maximum diagnostics to return (default: 100)" }
        }
    }
},
(object)new
{
    name = "ulsm:check_unity_patterns",
    description = "Check for Unity performance anti-patterns beyond standard analyzers. Detects GetComponent in Update loops, string concatenation in hot paths, Camera.main usage, Debug.Log in release code, and more. Provides specific suggestions for each issue.",
    inputSchema = new
    {
        type = "object",
        properties = new
        {
            filePath = new { type = "string", description = "File to analyze (required)" },
            includeInfo = new { type = "boolean", description = "Include informational (low severity) patterns (default: true)" },
            checkHotPathsOnly = new { type = "boolean", description = "Only check patterns in Update/FixedUpdate/LateUpdate (default: false)" }
        },
        required = new[] { "filePath" }
    }
},
(object)new
{
    name = "ulsm:api_migration",
    description = "Check for deprecated Unity API usage that should be migrated. Covers Unity 2022.x to Unity 6.x (6000.x) transitions including Input System, Networking (UNet removal), XR, and more. Returns migration suggestions with new API equivalents.",
    inputSchema = new
    {
        type = "object",
        properties = new
        {
            filePath = new { type = "string", description = "Optional: check specific file only" },
            projectPath = new { type = "string", description = "Optional: check specific project only" },
            targetVersion = new { type = "string", description = "Unity version to check migrations for (default: '6000.0')" },
            categoryFilter = new { type = "string", description = "Optional: filter by category - 'Input', 'Networking', 'Rendering', 'XR', etc." }
        }
    }
},
(object)new
{
    name = "ulsm:list_unity_rules",
    description = "List all available Unity diagnostic rules and migration patterns. Useful for understanding what the Unity analyzers can detect.",
    inputSchema = new
    {
        type = "object",
        properties = new { }
    }
},
```

#### 7.2 Add Tool Handlers

Add a private field for the Unity analysis service:

```csharp
private readonly RoslynService _roslynService;
private readonly UnityAnalysisService _unityAnalysisService;  // Add this

public McpServer()
{
    _roslynService = new RoslynService();
    _unityAnalysisService = new UnityAnalysisService(_roslynService);  // Add this
    // ...
}
```

Add using statement at top:

```csharp
using ULSM.Unity;
```

In `HandleToolCallAsync`, add the new tool handlers in the switch expression:

```csharp
"ulsm:unity_diagnostics" => await _unityAnalysisService.GetUnityDiagnosticsAsync(
    arguments?["filePath"]?.GetValue<string>(),
    arguments?["projectPath"]?.GetValue<string>(),
    arguments?["category"]?.GetValue<string>(),
    arguments?["includeSuppressions"]?.GetValue<bool>() ?? false,
    arguments?["maxResults"]?.GetValue<int>() ?? 100),

"ulsm:check_unity_patterns" => await _unityAnalysisService.CheckUnityPatternsAsync(
    arguments?["filePath"]?.GetValue<string>() ?? throw new Exception("filePath required"),
    arguments?["includeInfo"]?.GetValue<bool>() ?? true,
    arguments?["checkHotPathsOnly"]?.GetValue<bool>() ?? false),

"ulsm:api_migration" => await _unityAnalysisService.CheckApiMigrationAsync(
    arguments?["filePath"]?.GetValue<string>(),
    arguments?["projectPath"]?.GetValue<string>(),
    arguments?["targetVersion"]?.GetValue<string>() ?? "6000.0",
    arguments?["categoryFilter"]?.GetValue<string>()),

"ulsm:list_unity_rules" => _unityAnalysisService.GetAvailableDiagnostics(),
```

---

### Task 8: Update server.json

**File:** `src/server.json`

Document the new tools and their capabilities.

Add to the tools section:

```json
{
  "name": "ulsm:unity_diagnostics",
  "description": "Get Unity-specific diagnostics using Microsoft.Unity.Analyzers",
  "category": "Unity Analysis",
  "parameters": {
    "filePath": "Optional: analyze specific file only",
    "projectPath": "Optional: analyze specific project only",
    "category": "Optional: filter by category (messages, nullchecking, performance, bestpractices)",
    "includeSuppressions": "Include suppressed diagnostics (default: false)",
    "maxResults": "Maximum diagnostics to return (default: 100)"
  }
},
{
  "name": "ulsm:check_unity_patterns",
  "description": "Check for Unity performance anti-patterns beyond standard analyzers",
  "category": "Unity Analysis",
  "parameters": {
    "filePath": "File to analyze (required)",
    "includeInfo": "Include informational patterns (default: true)",
    "checkHotPathsOnly": "Only check patterns in Update/FixedUpdate/LateUpdate (default: false)"
  }
},
{
  "name": "ulsm:api_migration",
  "description": "Check for deprecated Unity API usage for migration",
  "category": "Unity Analysis",
  "parameters": {
    "filePath": "Optional: check specific file only",
    "projectPath": "Optional: check specific project only",
    "targetVersion": "Unity version (default: '6000.0')",
    "categoryFilter": "Optional: filter by category (Input, Networking, Rendering, XR, etc.)"
  }
},
{
  "name": "ulsm:list_unity_rules",
  "description": "List all available Unity diagnostic rules and migration patterns",
  "category": "Unity Analysis",
  "parameters": {}
}
```

---

## Validation Checklist

### Build Validation

```bash
# Clean and rebuild
dotnet clean ULSM.sln
dotnet restore ULSM.sln
dotnet build ULSM.sln

# Verify no build errors
# Verify Microsoft.Unity.Analyzers package restored
```

### Manual Testing

If a Unity project is available:

```bash
# Set environment variable to Unity solution
$env:DOTNET_SOLUTION_PATH = "C:\path\to\UnityProject\UnityProject.sln"

# Run ULSM
dotnet run --project src/ULSM.csproj
```

Test MCP requests:

```json
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}
```

```json
{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"ulsm:list_unity_rules","arguments":{}}}
```

```json
{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"ulsm:unity_diagnostics","arguments":{}}}
```

```json
{"jsonrpc":"2.0","id":4,"method":"tools/call","params":{"name":"ulsm:check_unity_patterns","arguments":{"filePath":"C:\\path\\to\\Script.cs"}}}
```

```json
{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"ulsm:api_migration","arguments":{"targetVersion":"6000.0"}}}
```

---

## Git Commit Strategy

Use conventional commit format for versionize changelog generation.

### Commit 1: Add Microsoft.Unity.Analyzers Package

```bash
git add src/ULSM.csproj
git commit -m "feat(unity): add Microsoft.Unity.Analyzers package

Add NuGet reference to Microsoft.Unity.Analyzers v1.19.0 for Unity-specific
diagnostic analysis capabilities."
```

### Commit 2: Add Unity Analyzer Infrastructure

```bash
git add src/Unity/Analyzers/
git commit -m "feat(unity): add Unity analyzer infrastructure

- Add UnityAnalyzerLoader for loading Microsoft.Unity.Analyzers
- Add UnityPatternAnalyzer for custom pattern detection
- Add UnityApiMigrationData for Unity 6.x migration rules
- Support category filtering and caching"
```

### Commit 3: Add UnityAnalysisService

```bash
git add src/Unity/UnityAnalysisService.cs src/RoslynService.cs
git commit -m "feat(unity): add UnityAnalysisService

- Add UnityAnalysisService to orchestrate Unity analysis
- Add GetUnityDiagnosticsAsync for analyzer-based diagnostics
- Add CheckUnityPatternsAsync for custom pattern detection
- Add CheckApiMigrationAsync for API migration checking
- Add GetSolution() accessor to RoslynService"
```

### Commit 4: Register Unity Analysis Tools

```bash
git add src/McpServer.cs src/server.json
git commit -m "feat(unity): register Unity analysis MCP tools

- Add ulsm:unity_diagnostics tool for Unity analyzer diagnostics
- Add ulsm:check_unity_patterns tool for custom pattern detection
- Add ulsm:api_migration tool for API migration checking
- Add ulsm:list_unity_rules tool for diagnostic discovery
- Document new tools in server.json"
```

### Commit 5: Add Assignment Prompt

```bash
git add Prompts/PP13-105/
git commit -m "docs: add PP13-105 Phase 3 assignment prompt

Add comprehensive implementation guide for Unity-specific analysis tools
including Microsoft.Unity.Analyzers integration and custom pattern detection."
```

---

## Dev Diary Logging

### At Start

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-105
entry_type: plan
content: Starting Phase 3 implementation - Unity-Specific Analysis Tools. Tasks: (1) Add Microsoft.Unity.Analyzers NuGet package, (2) Implement UnityAnalyzerLoader for loading analyzer instances, (3) Implement UnityPatternAnalyzer for custom pattern detection, (4) Implement UnityApiMigrationData for deprecation database, (5) Implement UnityAnalysisService as main orchestrator, (6) Register 4 new MCP tools (unity_diagnostics, check_unity_patterns, api_migration, list_unity_rules), (7) Update server.json documentation.
```

### During Implementation

Log at each major task completion with specific details.

### On Completion

```
/devdiary ASSIGNMENT: Create Diary Entry
issue_id: PP13-105
entry_type: work
content: Phase 3 complete. [Summary of what was implemented and tested, any deviations from plan]
```

---

## Success Criteria

Phase 3 is complete when:

1. **Package Integration**
   - [ ] Microsoft.Unity.Analyzers v1.19.0 added to ULSM.csproj
   - [ ] Package restores and builds correctly

2. **Analyzer Infrastructure**
   - [ ] UnityAnalyzerLoader loads analyzers from assembly
   - [ ] Category filtering works (messages, nullchecking, performance, bestpractices)
   - [ ] Analyzer caching implemented for performance

3. **Custom Pattern Detection**
   - [ ] Detects GetComponent in Update/FixedUpdate
   - [ ] Detects string operations in hot paths
   - [ ] Detects Camera.main usage
   - [ ] Detects Debug.Log in hot paths
   - [ ] Provides actionable suggestions

4. **API Migration Checking**
   - [ ] Database covers major Unity 6.x deprecations
   - [ ] Version filtering works correctly
   - [ ] Category filtering works
   - [ ] Findings include file/line locations

5. **MCP Tools**
   - [ ] ulsm:unity_diagnostics returns Unity analyzer diagnostics
   - [ ] ulsm:check_unity_patterns returns custom pattern issues
   - [ ] ulsm:api_migration returns API migration findings
   - [ ] ulsm:list_unity_rules returns available diagnostics

6. **Build & Quality**
   - [ ] `dotnet build ULSM.sln` succeeds with no new errors
   - [ ] All commits follow conventional commit format
   - [ ] server.json documents new tools

---

## Next Phase

After completing PP13-105, proceed to:
- **PP13-106: Phase 4 - Testing Infrastructure** (NUnit tests, minimal Unity test project)

---

## Appendix A: Key Microsoft.Unity.Analyzers Diagnostics

| ID | Title | Severity |
|----|-------|----------|
| UNT0001 | Empty Unity message | Info |
| UNT0002 | Inefficient tag comparison | Warning |
| UNT0003 | Non-generic GetComponent | Warning |
| UNT0004 | Time.fixedDeltaTime in Update | Info |
| UNT0005 | Time.deltaTime in FixedUpdate | Info |
| UNT0006 | Incorrect message signature | Error |
| UNT0007 | Null coalescing on Unity type | Warning |
| UNT0008 | Null propagation on Unity type | Warning |
| UNT0009 | Missing SerializeField/SerializeReference | Info |
| UNT0010 | MonoBehaviour instantiated with new | Warning |
| UNT0011 | ScriptableObject instantiated with new | Warning |
| UNT0012 | Coroutine without yield | Warning |
| UNT0013 | Invalid SerializeField attribute | Warning |
| UNT0014 | GetComponent called with non-Component | Error |
| UNT0015 | Incorrect method name in Invoke | Warning |
| UNT0016 | Unsafe Camera.main usage | Warning |
| UNT0017 | SetPixels performance | Warning |
| UNT0018 | System.Reflection feature | Info |
| UNT0019 | Unnecessary Invoke | Warning |
| UNT0020 | MenuItem method static | Error |
| UNT0021 | Protected Unity message | Info |
| UNT0022 | Unity object with ?? operator | Warning |
| UNT0023 | Coalescing assignment on Unity | Warning |
| UNT0024 | Float/double precision | Info |
| UNT0025 | Input.GetKey vs Input.GetButton | Info |

## Appendix B: Custom Pattern IDs (ULSM-specific)

| ID | Title | Category |
|----|-------|----------|
| ULSM0001 | Expensive call in hot path | Performance |
| ULSM0002 | String operation in hot path | Performance |
| ULSM0003 | Debug logging in hot path | Performance |
| ULSM0004 | Camera.main usage | Performance |

## Appendix C: Migration Category Reference

| Category | Scope |
|----------|-------|
| Input | Legacy Input Manager → New Input System |
| Networking | UNet → Netcode for GameObjects |
| Rendering | Graphics API changes, SRP |
| UI | Legacy UI → UI Toolkit |
| XR | Legacy VR/AR → OpenXR |
| Physics | Physics API changes |
| Animation | Legacy → Animator |
| Audio | Audio API updates |
| Editor | Editor API changes |
| Coroutines | Async patterns |
| Particles | Particle System updates |
